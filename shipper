#!/usr/bin/env python
#
# shipper -- a tool for shipping software

import sys, os, readline, re, commands, time, glob, optparse, stat, email

#
# State variables
#
destinations = []	# List of remote directories to update
whoami = None		# Who am I? (Used for FTP logins and mail signatures)
date = None		# User has not yet set a date
package = None   	# Nor a package name
website = None		# Nor a home page
project_tags = None  	# Keywords for tagging
freshmeat_name = None	# Name of the project on Freshmeat
berlios_name = None	# Name of the project on derlios,de
changelog = None	# Project changelog
lastchange = None  	# Last entry in changelog
summary = None   	# One-line summary of the package
description = None	# Nor a description

# Policy choices
tag_template = "%s"
tag_message = "Tagged for external release %s"

indextemplate = """
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html>
<head>
<meta name='description' content='Resource page for %(package)s' />
<meta name='generator' content='shipper' />
<meta name='MSSmartTagsPreventParsing' content='TRUE' />
<title>Resource page for %(package)s %(version)s</title>
</head>
<body>

<h1>Resource page for %(package)s %(version)s</td></h1>

<p>%(description)s</p>

<br />
%(resourcetable)s
<br />

<p>Last modified %(date)s.</p>

</div>
</body>
</html>
"""

mailtemplate = """Subject: Announcing release %(version)s of %(package)s

Release %(version)s of %(package)s is now available at:

	%(website)s

Here are the most recent changes:

%(lastchange)s
--
                             shipper, acting for %(whoami)s
"""

# It's unpleasant that we have to include these here, but
# the new API doesn't have any facility that allow us to
# validate these.
freshmeat_focus_types = (
"N/A",
"Initial freshmeat announcement",
"Documentation",
"Code cleanup",
"Minor feature enhancements",
"Major feature enhancements",
"Minor bugfixes",
"Major bugfixes",
"Minor security fixes",
"Major security fixes",
)

def croak(msg):
    sys.stderr.write("shipper: " + msg + "\n")
    sys.exit(1)

#
# Shipping methods
#

def do_or_die(cmd):
    "Either execute a command or fail noisily, letting output go to stdout."
    if options.verbose:
        print "***", cmd
    if os.system(cmd):
        croak("command '%s' failed!" % cmd)

def trap_or_die(cmd):
    "Either execute a command or fail noisily, capturing output."
    if options.verbose:
        print "***", cmd
    (status, output) =  commands.getstatusoutput(cmd)
    if status:
        croak("command '%s' failed!" % cmd)
    else:
        return output

def upload_or_die(cmd):
    if options.noupload:
        print cmd
    else:
        do_or_die(cmd)

def upload(destination, files, subdir=None):
    "Upload a file via scp, deleting with ssh first if it exists."
    if subdir == None:
        subdir=package
    print "# Uploading to %s" % destination
    files = filter(os.path.exists, files)
    if destination.startswith("ftp://"):
        destination = destination[6:].split("/")
        host = destination.pop(0)
        directory = "/".join(destination)
        (realname, address) = email.utils.parseaddr(whoami)
        commands = ["lftp\n", "open -u anonymous," + address + " " + host + "\n"]
        if directory:
            commands.append("cd " + directory + "\n")
        commands.append("mput " + " ".join(files) + "\n")
        commands.append("close\n")
        if options.noupload:
            print "".join(commands)
        else:
            pfp = os.popen(commands.pop(0), "w")
            pfp.writelines(commands)
            pfp.close()
    elif destination.find("::") > -1:
        upload_or_die("rsync " + " ".join(files) + " " + destination)
    elif destination.find(":") > -1:
        (host, directory) = destination.split(":")
        for file in files:
            # This is a really ugly way to deal with the problem
            # of write-protected files in the remote directory.
            # Unfortunately, sftp(1) is rather brain-dead -- no
            # way to ignore failure on a remove, and refuses to
            # do renames with an obscure error message.
            remote = os.path.join(directory, subdir, os.path.basename(file))
            upload_or_die("scp " + file + " " + host + ":" + remote+".new;")
            upload_or_die("ssh %s 'mv -f %s.new %s'" % (host, remote, remote))
    else:
        sys.stderr.write("Don't know what to do with destination %s!\n" % destination)

def freshmeat_ship(manifest):
    "Ship a specified update to freshmeat."
    if options.verbose:
        print "Announcing to freshmeat..."
    upload_or_die("freshmeat-submit <" + manifest[0])

def make_index_page(deliverables):
    "Make index page, listing specified deliverables."
    print "# Building index.html..."
    global resourcetable
    resourcetable = '<table border="1" align="center" summary="Downloadable resources">\n'
    for (file, explanation, urlify) in deliverables:
        resourcetable += "<tr><td><a href='%s'>%s</a></td><td>%s</td></tr>\n" % (file,file,explanation)
    resourcetable += "</table>"
    # OK, now build the index page itself
    ofp = open("index.html", "w")
    ofp.write(indextemplate % globals())
    ofp.close()

#
# Metadata extraction
#

def grep(pattern, file):
    "Mine for a specified pattern in a file."
    fp = open(file)
    try:
        while True:
            line = fp.readline()
            if not line:
                return None
            m = re.search(pattern, line)
            if m:
                return m.group(1)
    finally:
        fp.close()
    return None

class Specfile:
    def __init__(self, filename):
        self.filename = filename
        self.type = None
        if filename.endswith(".spec"):
            self.type = "RPM"
            self.package = self.extract("Name")
            self.version = self.extract("Version")
            self.website = self.extract("URL")
            self.summary = self.extract("Summary")
            self.description = self.rpm_get_multiline("description")
        elif filename == "control":
            self.type = "deb"
            self.name = self.extract("Package")
            self.version = self.extract("Version").split("-")[0]
            self.website = self.extract("Homepage")
            self.summary = self.extract("Description")
            fp = open(self.filename)
            desc = ""
            gather = False
            while True:
                line = fp.readline()
                if not line:
                    break
                if line.startswith("Description:"):
                    gather = True
                    continue
                elif not line.strip():
                    gather = False
                if gather:
                    if line == " .\n":
                        line = "\n"
                    else:
                        line = line[1:]
                    desc += line
            fp.close()
            if desc:
                self.description = desc.strip() + "\n"
            else:
                self.description = None
    def extract(self, fld):
        "Extract a one-line field, possibly embedded as a magic comment."
        if self.type == "RPM":
            return grep("^#?"+fld+":\s*(.*)", self.filename)
        elif self.type == "deb":
            return grep("^(?:XBS-)?"+fld+": (.*)", self.filename)
    def rpm_get_multiline(self, fieldname):
        "Grab everything from leader line to just before the next leader line."
        global desc
        fp = open(self.filename)
        desc = ""
        gather = False
        while True:
            line = fp.readline()
            if not line:
                break
            # Pick up fieldnames *without* translation options.
            if line.strip() == "%" + fieldname:
                gather = True
                continue
            elif line[0] == "%":
                gather = False
            if gather:
                desc += line
        fp.close()
        if desc:
            return desc.strip() + "\n"
        else:
            return None
#
# Main sequence
#

try:
    #
    # Process options
    #

    parser = optparse.OptionParser(usage="%prog: [-n] [-f] [-v]")
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="print progress messages to stdout")
    parser.add_option("-n", "--noupload",
                      action="store_true", dest="noupload", default=False,
                      help="don't do uploads, just build deliverables")
    parser.add_option("-N", "--nobuild",
                      action="store_true", dest="nobuild", default=False,
                      help="dump configuration only, no builds or uploads")
    (options, args) = parser.parse_args()

    #
    # Extract metadata and compute control information
    #

    def disable(s): destinations.remove(s)

    # Security check, don't let an attacker elevate privileges 
    def securecheck(file):
        if stat.S_IMODE(os.stat(file).st_mode) & 00002:
            croak("%s must not be world-writeable!" % file)

    # Read in variable overrides
    securecheck(".")
    home_profile = os.path.join(os.getenv('HOME'), ".shipper")
    if os.path.exists(home_profile):
        securecheck(home_profile)
        execfile(home_profile)
    here_profile = ".shipper"
    if os.path.exists(here_profile):
        securecheck(here_profile)
        execfile(here_profile)

    # Set various sensible defaults
    if not whoami:
        croak("please set whoami in your .shipper file.")

    # Where to get the metadata
    specfiles = glob.glob("*.spec")
    if len(specfiles) == 1:
        metadata = Specfile(specfiles[0])
    elif os.path.exists("control"):
        metadata = Specfile("control")
    else:
        croak("must be exactly one RPM or dpkg control file in the directory!")

    # Get the package name
    if not package:
        package = metadata.package
    if not package:
        croak("can't get package name!")

    # Extract the package version from the specfile or Makefile
    specvers = metadata.version
    makevers = None
    makefile = None
    if os.path.exists("Makefile"):
        makefile = "Makefile"        
    if os.path.exists("makefile"):
        makefile = "makefile"
    if makefile:
        makevers = grep("^VERS[A-Z]* *= *(.*)", makefile)
        # Maybe it's a shell command intended to extract version from specfile
        if makevers and makevers[0] == '$':
            makevers = commands.getoutput(makevers[7:-1])
    if makevers and specvers != makevers:
        croak("specfile version %s != Makefile version %s"%(specvers,makevers))
    elif specvers == None:
        croak("can't get package version")
    elif specvers[0] not in "0123456789":
        croak("package version %s appears garbled" % specvers)
    else:
        version = specvers

    # Specfiles may set their own destinations
    local_destinations = metadata.extract("Destinations")
    if local_destinations:
        local_destinations = map(lambda x: x.strip(), local_destinations.split(","))
        destinations += local_destinations

    print "# Uploading version %s of %s" % (version, package)

    # Extract remaining variables for templating
    if not website:
        website = metadata.website
    if not date:
        date = time.asctime()
    if not summary:
        summary = metadata.summary
    if not description:
        description = metadata.description
    if not project_tags:
        project_tags = metadata.extract("Project-Tags")
    if not freshmeat_name:
        freshmeat_name = metadata.extract("Freshmeat-Name")
    if not berlios_name:
        berlios_name = metadata.extract("Berlios-Name")
    resourcetable = ""

    if options.verbose:
        print "shipper: variable extraction finished"

    # Finally, derive the lastchange entry; we'll need it for
    # freshmeat.net (and someday for berlios.de).
    lastchange = None
    for filename in ("NEWS", "ChangeLog"):
        if os.path.exists(filename):
            if options.verbose:
                print "shipper: I see a %s file" % filename
            state = 0
            for line in open(filename, "r"):
                print "I see", line
                if state == 0:       # Skipping header
                    if line.startswith(" ") or line.startswith("\t"):
                        continue
                    elif not line.strip():
                        continue
                    else:
                        lastchange = line
                        state = 1
                elif state == 1:     # Past header
                    if not line.strip():
                        break
                    else:
                        lastchange += line
    if 'freshmeat' in destinations and not lastchange:
        croak("Freshmeat notification requires a NEWS or HISTORY file.")

    #
    # Now compute the names of deliverables
    #
    def versioned(filename):
        "Does the specfied filename contain a version number?"
        return re.search("[0-9]", filename)

    if options.verbose:
        print "shipper: starting deliverables computation"

    # Stuff not included here: SHIPPER.EMAIL, SHIPPER.FRESHMEAT.
    deliverable_types = (
        (re.compile("^README$"),
         "roadmap file",           None),
        (re.compile("^ChangeLog$"),
         "change log",             "ChangeLog"),
        (re.compile("^NEWS$"),
         "project news",           None),
        (re.compile("^HISTORY$"),
         "project history",        None),
        (re.compile("^BUGS$"),
         "known bugs",             None),
        (re.compile("^TODO$"),
         "to-do file",             None),
        (re.compile(package + ".*-" + version + r".(tar.gz|tgz)$"),
         "gzipped source tarball", "Tar/GZ"),
        (re.compile(package + ".*-" + version + r".tar.bz2$"),
         "bzipped source tarball", "Tar/BZ"),
        (re.compile(package + ".*-" + version + r".zip$"),
         "zip archive",            "Zip"),
        (re.compile(package + ".*-" + version + r"-.*\.src.rpm$"),
         "source RPM",              "SRPM"),
        (re.compile(package + ".*-" + version + r"-.*\.rpm$"),
         "binary RPM",              "RPM"),
        (re.compile(package + ".*-" + version + r"-.*\.deb$"),
         "Debian package",          "Deb"),
        )
    deliverables = []
    for filename in os.listdir("."):
        for (pattern, explanation, tag) in deliverable_types: 
            if pattern.search(filename):
                deliverables.append((filename, explanation, tag))
    if options.verbose:
        print "Deliverables:", " ".join(map(lambda x: x[0], deliverables))

    #
    # Might be time to dump
    #
    if options.nobuild:
        for variable in ('destinations', 'whoami', 'date', 
                         'package', 'website', 'project_tags', 
                         'freshmeat_name', 'berlios_name', 'summary',
                         'tag_template', 'tag_message'):
            print "%s = %s" % (variable, `eval(variable)`)
        for variable in ('description', 'changelog', 'lastchange', 'mailtemplate', 'indextemplate'):
            if not eval(variable):
                print "No %s" % variable
            else:
                print "%s = <<EOF\n%sEOF" % (variable, eval(variable))
        raise SystemExit, 0
    #
    # Build deliverables
    #

    # Sanity checks
    if not filter(versioned, map(lambda (f, e, t): f, deliverables)):
        croak("no deliverables with versions!")
    if not destinations:
        croak("the Destinations list is empty; nothing to do.")

    if options.verbose:
        print "shipper: sanity checks passed"

    # Compute other deliverables, we need this even if not rebuilding
    # the index. Includes anything with an HTML, Javascript, or CSS
    # extension.
    for filename in glob.glob('*.html')+glob.glob('*.js')+glob.glob('*.css'):
        if filename == 'index.html':
            continue
        stem = filename[:-4]
        for ext in ("man", "1", "2", "3", "4", "5", "6", "7", "8", "9", "xml"):
            if os.path.exists(stem + ext):
                explanation = "HTML rendering of " + stem + ext
                break
        else:
            explanation = "HTML page."
        deliverables.append((filename, explanation, None))

    # If a web page doesn't already exist, but the index template
    # variable is nonempty (which is the default) make one.  
    if website and indextemplate and not os.path.exists("index.html"):
        make_index_page(deliverables)
        # Now that the web page has been generated, it can add
        # itself to the deliverables without having it show up in
        # the resource table.
        deliverables.append(("index.html", "index web page", None))

    # The freshmeat announcement
    if 'freshmeat' in destinations:
        print "# Building SHIPPER.FRESHMEAT..."
        if not website:
            print "# Can't announce to freshmeat without a primary website!"
        elif not lastchange:
            print "# Can't announce to freshmeat without a changes field!"
        else:
            while True:
                focus = raw_input("# freshmeat.net release focus (? for list): ")
                if focus == '?':
                    i = 0
                    for f in freshmeat_focus_types:
                        print "%d: %s" % (i, f)
                        i += 1
                elif focus in "0123456789":
                    focus = freshmeat_focus_types[int(focus)]
                    print "# OK:", focus
                    break
                elif focus.lower() in map(lambda x: x.lower(), freshmeat_focus_types):
                    break
                else:
                    croak("not a valid freshmeat.net release focus!")
            # Download directory has to be computed differently at
            # special destinations
            if website.find("berlios"):
                download = "http://download.berlios.de/"+(berlios_name or package)
            else:
                download = website
            ofp = open("SHIPPER.FRESHMEAT", "w")
            ofp.write("Project: %s\n" % (freshmeat_name or package))
            ofp.write("Version: %s\n" % version)
            if project_tags:
                ofp.write("Project-Tags: %s\n" % project_tags)
            ofp.write("Release-Focus: %s\n" % focus)
            ofp.write("Website-URL: %s\n" % website)
            for (f, e, s) in deliverables:
                if s:
                    ofp.write("%s-URL: %s\n" % (e, os.path.join(website, f)))
            # freshmeat.net doesn't like bulleted entries.
            freshmeatlog = lastchange.replace("\n  ", "\n")
            ofp.write("\n" + freshmeatlog)
            ofp.close()

    # Finally, email notification
    maildests = filter(lambda x: x.startswith("mailto:"), destinations)
    if maildests:
        print "# Building SHIPPER.EMAIL..."
        ofp = open("SHIPPER.EMAIL", "w")
        ofp.write("To: " + ", ".join(map(lambda x: x[7:], maildests)) + "\n")
        ofp.write(mailtemplate % globals())
        ofp.close()

    #
    # Now actually ship
    #

    # Compute final deliverables
    all_deliverables = map(lambda x: x[0], deliverables)
    download_deliverables = filter(versioned,
                                   map(lambda x: x[0], deliverables))
    web_deliverables = filter(lambda f: not versioned(f),
                              map(lambda x: x[0], deliverables))

    # Shipping methods for public destinations.
    def freshmeat():
        freshmeat_ship(("SHIPPER.FRESHMEAT",))
    def berlios():
        upload("ftp://ftp.berlios.de/incoming", download_deliverables)
        berlios_webdir = \
                       "shell.berlios.de:/home/groups/" \
                       + (berlios_name or package) \
                       + "/htdocs"
        upload(berlios_webdir, web_deliverables, subdir="")
    hardwired = ("freshmeat", "berlios")

    # OK, ship everything.
    for destination in destinations:
        if destination in hardwired:
            print "# Shipping to public destination", destination
            eval(destination + "()")
        elif destination.startswith("ftp:"):
            upload(destination, download_deliverables)
        elif destination.startswith("mailto:"):
            print "# Mailing to %s" % destination[7:]
            command = "sendmail -i -oem -f %s %s <SHIPPER.EMAIL" % (whoami, destination[7:])
            if options.noupload:
                print command
            else:
                do_or_die(command)
        elif destination not in hardwired:
            upload(destination, all_deliverables)

    # Shipping has succeeded.
    if tag_template and tag_message:
        tagname = tag_template % version
        tag_message = tag_message % version

        # If we're in the trunk of an SVN repository, we want to tag
        # what just got shipped as an external release (unless the tag
        # already exists, or the user suppressed this behavior by
        # setting subversion_tag_template to None or "").
        if os.path.basename(os.getcwd())=='trunk' and os.path.exists(".svn"):
            print "# This is a Subversion trunk directory..."
            if os.path.exists("../tags"):
                print "# I see a peer tags directory..."
                if os.path.exists("../tags/" + tagname):
                    print "# This release has aleady been tagged."
                else:
                    print "# I will copy and tag this release."
                    upload_or_die("cd .. && svn copy trunk tags/%s && svn -m '%s' commit" % (tagname, tag_message))
        if os.path.exists(".git"):
            print "# This is a git repository..."
            if os.path.exists(".git/refs/tags/" + tagname):
                print "# This release has aleady been tagged."
            else:
                print "# I will tag this release."
                upload_or_die("git tag -a %s -m '%s'" % (tagname, tag_message))
    print "# Done"
except KeyboardInterrupt:
    print "# Bye!"

# The following sets edit modes for GNU EMACS
# Local Variables:
# mode:python
# End:
