#!/usr/bin/env python
#
# shipper -- a tool for shipping software

import sys, os, readline, re, commands, time
import glob, optparse, stat, email, smtplib, ConfigParser

version="0.10"

#
# State variables
#
destinations = []	# List of remote directories to update
whoami = None		# Who am I? (Used for FTP logins and mail signatures)
date = None		# User has not yet set a date
package = None   	# Nor a package name
website = None		# Nor a home page
project_tags = None  	# Keywords for tagging
freshmeat_name = None	# Name of the project on Freshmeat
berlios_name = None	# Name of the project on berlios,de
sourceforge_name = None # Name of the project on sourceforge.net
changelog = None	# Project changelog
lastchange = None  	# Last entry in changelog
summary = None   	# One-line summary of the package
description = None	# Nor a description
extralines = ""         # Extra lines for HTML template

# Policy choices
tag_template = "%s"
tag_message = "Tagged for external release %s"

indextemplate = """
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html>
<head>
<meta name='description' content='Resource page for %(package)s' />
<meta name='generator' content='shipper' />
<meta name='MSSmartTagsPreventParsing' content='TRUE' />
<meta name='description' content="%(summary)s"/>
<title>Resource page for %(package)s %(version)s</title>
</head>
<body>

<h1>Resource page for %(package)s %(version)s</td></h1>

<p>%(description)s</p>

<br />
%(resourcetable)s
<br />

%(extralines)s

<p>Last modified %(date)s.</p>

</div>
</body>
</html>
"""

mailtemplate = """Subject: Announcing release %(version)s of %(package)s

Release %(version)s of %(package)s is now available at:

	%(website)s

Here are the most recent changes:

%(lastchange)s
--
                             shipper, acting for %(whoami)s
"""

# It's unpleasant that we have to include these here, but
# the new API doesn't have any facility that allow us to
# validate these.
freshmeat_focus_types = (
"N/A",
"Initial freshmeat announcement",
"Documentation",
"Code cleanup",
"Minor feature enhancements",
"Major feature enhancements",
"Minor bugfixes",
"Major bugfixes",
"Minor security fixes",
"Major security fixes",
)

def croak(msg):
    sys.stderr.write("shipper: " + msg + "\n")
    sys.exit(1)

#
# Shipping methods
#

def do_or_die(cmd):
    "Either execute a command or fail noisily, letting output go to stdout."
    if options.verbose:
        print "***", cmd
    if os.system(cmd):
        croak("command '%s' failed!" % cmd)

def trap_or_die(cmd):
    "Either execute a command or fail noisily, capturing output."
    if options.verbose:
        print "***", cmd
    (status, output) =  commands.getstatusoutput(cmd)
    if status:
        croak("command '%s' failed!" % cmd)
    else:
        return output

def upload_or_die(cmd):
    if options.upload:
        do_or_die(cmd)
    else:
        print cmd

def upload(destination, files, subdir=None):
    "Upload a file via ftp or scp."
    if subdir == None:
        subdir=package
    print "# Uploading to %s" % destination
    files = filter(os.path.exists, files)
    if destination.startswith("ftp://"):
        destination = destination[6:].split("/")
        host = destination.pop(0)
        directory = "/".join(destination)
        commands = ["lftp\n", "open -u anonymous," + myaddress + " " + host + "\n"]
        if directory:
            commands.append("cd " + directory + "\n")
        commands.append("mput " + " ".join(files) + "\n")
        commands.append("close\n")
        if options.upload:
            pfp = os.popen(commands.pop(0), "w")
            pfp.writelines(commands)
            pfp.close()
        else:
            print "".join(commands)
    elif destination.find(":") > -1:
        (host, directory) = destination.split(":")
        for file in files:
            # Requires your files to be writeable by you - maybe not so if they
            # were RCSed but not locked! If they are, the -p option to scp
            # will set that permission on the remote host and allow you to
            # update the files with scp later.
            remote = os.path.join(directory, subdir, os.path.basename(file))
            upload_or_die("scp -p " + file + " " + host + ":" + remote)
    else:
        sys.stderr.write("Don't know what to do with destination %s!\n" % destination)

def freshmeat_ship(job_card):
    "Ship a specified update to freshmeat."
    if options.upload:
        upload_or_die("freshmeat-submit <" + job_card)
    print "Announcing to freshmeat <<EOF"
    sys.stdout.write(open(job_card).read())
    print "EOF"

def make_index_page(deliverables):
    "Make index page, listing specified deliverables."
    print "# Building index.html..."
    global resourcetable, extralines
    resourcetable = '<table border="1" align="center" summary="Downloadable resources">\n'
    for (file, explanation, urlify) in deliverables:
        resourcetable += "<tr><td><a href='%s'>%s</a></td><td>%s</td></tr>\n" % (file,file,explanation)
    resourcetable += "</table>"
    if 'freshmeat' in destinations:
        extralines += "<p>There is a Freshmeat <a href='http://freshmeat.net/projects/%s'>%s page</a>.</p>\n" % \
                      (freshmeat_name, freshmeat_name)
    # OK, now build the index page itself
    ofp = open("index.html", "w")
    ofp.write(indextemplate % globals())
    ofp.close()

#
# Metadata extraction
#

def grep(pattern, file):
    "Mine for a specified pattern in a file."
    # Note: this blank-strips its output!
    fp = open(file)
    try:
        while True:
            line = fp.readline()
            if not line:
                return None
            m = re.search(pattern, line)
            if m:
                return m.group(1).strip()
    finally:
        fp.close()
    return None

class Specfile:
    def __init__(self, filename):
        self.filename = filename
        self.type = None
        if filename.endswith(".spec"):
            self.type = "RPM"
            self.package = self.extract("Name")
            self.version = self.extract("Version")
            self.website = self.extract("URL")
            self.summary = self.extract("Summary")
            self.description = self.rpm_get_multiline("description")
            last = ""
            state = 0
            for line in open(self.filename):
                if state == 0:
                    if line.startswith("%changelog"):
                        state = 1
                        continue
                elif state == 1:
                    # Skip first line of entry
                    state = 2
                    continue
                elif state == 2:
                    if not line.strip():
                        break
                    else:
                        if line.strip().startswith("-"):
                            line = line.lstrip()[1:]
                        last += line
            if last:
                self.lastchange = last
            else:
                self.lastchange = None
        elif filename == "control":
            self.type = "deb"
            self.package = self.extract("Package")
            self.version = self.extract("Version")
            if self.version and "-" in self.version:
                self.version = self.version.split("-")[0]
            self.website = self.extract("Homepage")
            self.summary = self.extract("Description")
            fp = open(self.filename)
            desc = ""
            gather = False
            while True:
                line = fp.readline()
                if not line:
                    break
                if line.startswith("Description:"):
                    gather = True
                    continue
                elif not line.strip():
                    gather = False
                if gather:
                    if line == " .\n":
                        line = "\n"
                    else:
                        line = line[1:]
                    desc += line
            fp.close()
            if desc:
                self.description = desc.strip() + "\n"
            else:
                self.description = None
            self.lastchange = None
    def extract(self, fld):
        "Extract a one-line field, possibly embedded as a magic comment."
        if self.type == "RPM":
            return grep("^#?"+fld+":\s*(.*)", self.filename)
        elif self.type == "deb":
            return grep("^(?:XBS-)?"+fld+": (.*)", self.filename)
    def rpm_get_multiline(self, fieldname):
        "Grab everything from leader line to just before the next leader line."
        global desc
        fp = open(self.filename)
        desc = ""
        gather = False
        while True:
            line = fp.readline()
            if not line:
                break
            # Pick up fieldnames *without* translation options.
            if line.strip() == "%" + fieldname:
                gather = True
                continue
            elif line[0] == "%":
                gather = False
            if gather:
                desc += line
        fp.close()
        if desc:
            return desc.strip() + "\n"
        else:
            return None
#
# Who am I? 
#
def whoami_really():
    "Ask various programs that keep track of who you are who you are."
    # Bazaar version-control system
    (bzrerr, bzrout) = commands.getstatusoutput("bzr config email")
    if bzrerr == 0 and bzrout:
        return bzrout
    # Git version-control system
    (nameerr, nameout) = commands.getstatusoutput("git config user.name")
    (emailerr, emailout) = commands.getstatusoutput("git config user.email")
    if nameerr == 0 and nameout and emailerr == 0 and emailout:
        return "%s <%s>" % (nameout, emailout)
    # Various random configs
    for (fn, mine) in (
        ("~/.hgrc", r"username\s*=\s*(.*)"),                # Mercurial
        ("~/.lynxrc", r"personal_mail_address\s*=\s*(.*)")  # Lynx
        ):
        fn = os.expanduser(fn)
        if os.path.exists(fn):
            for line in file(fn):
                m = re.search(mine, line)
                if m:
                    return m.group(1)
    # Out of alternatives
    return None

#
# Main sequence
#

try:
    #
    # Process options
    #

    parser = optparse.OptionParser(usage="%prog: [-u] [-f] [-v]")
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="print progress messages to stdout")
    parser.add_option("-u", "--upload",
                      action="store_true", dest="upload", default=False,
                      help="do uploads")
    parser.add_option("-n", "--nobuild",
                      action="store_true", dest="nobuild", default=False,
                      help="dump configuration only, no builds or uploads")
    parser.add_option("-m", "--makeindex",
                      action="store_true", dest="makeindex", default=False,
                      help="generate an index.html for websites")
    parser.add_option("-t", "--tag",
                      action="store_true", dest="vcstag", default=False,
                      help="tag repo for external release after shipping")
    parser.add_option("-x", "--exclude",
                      dest="excluded", default="",
                      help="exclude some shipping targets")
    (options, args) = parser.parse_args()

    #
    # Extract metadata and compute control information
    #

    def disable(s): destinations.remove(s)

    # Security check, don't let an attacker elevate privileges 
    def securecheck(file):
        if stat.S_IMODE(os.stat(file).st_mode) & 00002:
            croak("%s must not be world-writeable!" % file)

    # Read in variable overrides
    securecheck(".")
    home_profile = os.path.join(os.getenv('HOME'), ".shipper")
    if os.path.exists(home_profile):
        securecheck(home_profile)
        execfile(home_profile)
    here_profile = ".shipper"
    if os.path.exists(here_profile):
        securecheck(here_profile)
        execfile(here_profile)

    # Hack the destinations variable if need be, might mean we can avoid some
    # builds.
    if options.excluded:
        for excludee in options.excluded.split(","):
            if excludee in destinations:
                destinations.remove(excludee)
            else:
                print >>sys.stderr, "shipper: %s isn't in the destinations!" % excludee
                raise SystemExit,1

    # Set various sensible defaults
    if not whoami:
        whoami = whoami_really()
    if not whoami:
        croak("please set whoami in your .shipper file.")
    (myrealname, myaddress) = email.utils.parseaddr(whoami)
    (myuserid, myhost) = myaddress.split("@")

    # Where to get the metadata
    specfiles = glob.glob("*.spec")
    if len(specfiles) == 1:
        metadata = Specfile(specfiles[0])
    elif os.path.exists("control"):
        metadata = Specfile("control")
    else:
        croak("must be exactly one RPM or dpkg control file in the directory!")

    # Get the package name
    if not package:
        package = metadata.package
    if not package:
        croak("can't get package name!")

    # Extract the package version from the specfile or Makefile
    makevers = None
    makefile = None
    if os.path.exists("Makefile"):
        makefile = "Makefile"        
    if os.path.exists("makefile"):
        makefile = "makefile"
    if makefile:
        makevers = grep("^VERS[A-Z]* *= *(.*)", makefile)
        # Maybe it's a shell command intended to extract version from specfile
        if makevers and makevers[0] == '$':
            makevers = commands.getoutput(makevers[7:-1])
        if makevers[0] == '"' and makevers[-1] == '"':
            makevers = makevers[1:-1]
    if makevers and metadata.version and metadata.version != makevers:
        croak("specfile version %s != Makefile version %s"%(metadata.version,makevers))
    else:
        version = makevers or metadata.version
    if version == None:
        croak("can't get package version")
    elif version[0] not in "0123456789":
        croak("package version %s appears garbled" % version)

    # Specfiles may set their own destinations
    local_destinations = metadata.extract("Destinations")
    if local_destinations:
        local_destinations = map(lambda x: x.strip(), local_destinations.split(","))
        destinations += local_destinations

    print "# Uploading version %s of %s" % (version, package)

    # Extract remaining variables for templating
    if not website:
        website = metadata.website
    if not date:
        date = time.asctime()
    if not summary:
        summary = metadata.summary
    if not description:
        description = metadata.description
    if not project_tags:
        project_tags = metadata.extract("Project-Tag-List")
    freshmeat_name = metadata.extract("Freshmeat-Name")
    if not freshmeat_name:
        freshmeat_name = package
    berlios_name = metadata.extract("Berlios-Name")
    if not berlios_name:
        berlios_name = package
    sourceforge_name = metadata.extract("SourceForge-Name")
    if sourceforge_name:
        if "@" in sourceforge_name:
            (sourceforge_userid, sourceforge_name) = sourceforge_name.split("@")
    else:
        sourceforge_name = package
        sourceforge_userid = myuserid
    resourcetable = ""

    if options.verbose:
        print "shipper: variable extraction finished"

    # Finally, derive the lastchange entry; we'll need it for
    # freshmeat.net (and someday for berlios.de).
    lastchange = None
    for filename in ("NEWS", "HISTORY", "ChangeLog"):
        if not lastchange and os.path.exists(filename):
            if options.verbose:
                print "shipper: I see a %s file" % filename
            state = 0
            for line in open(filename, "r"):
                if state == 0:       # Skipping header
                    if line.startswith(" ") or line.startswith("\t"):
                        continue
                    elif not line.strip():
                        continue
                    else:
                        # Skip first line in the log entry.
                        lastchange = ""
                        state = 1
                elif state == 1:     # Past header
                    if not line.strip():
                        break
                    else:
                        lastchange += line
    if not lastchange and metadata.lastchange:
        lastchange = metadata.lastchange
    if 'freshmeat' in destinations and not lastchange:
        croak("Freshmeat notification requires a NEWS, HISTORY or ChangeLog file.")

    #
    # Now compute the names of deliverables
    #
    def versioned(filename):
        "Does the specfied filename contain a version number?"
        return re.search("[0-9]", filename)

    if options.verbose:
        print "shipper: starting deliverables computation"

    # Stuff not included here: SHIPPER.EMAIL, SHIPPER.FRESHMEAT.
    deliverable_types = (
        (re.compile("^README$"),
         "roadmap file",           None),
        (re.compile("^READ.ME$"),
         "roadmap file",           None),
        (re.compile("^ChangeLog$"),
         "change log",             "ChangeLog"),
        (re.compile("^NEWS$"),
         "project news",           None),
        (re.compile("^HISTORY$"),
         "project history",        None),
        (re.compile("^BUGS$"),
         "known bugs",             None),
        (re.compile("^TODO$"),
         "to-do file",             None),
        (re.compile("^COPYING$"),
         "project license",        None),
        (re.compile(package + ".*-" + version + r".(tar.gz|tgz)$"),
         "gzipped source tarball", "Tar/GZ"),
        (re.compile(package + ".*-" + version + r".tar.bz2$"),
         "bzipped source tarball", "Tar/BZ"),
        (re.compile(package + ".*-" + version + r".zip$"),
         "zip archive",            "Zip"),
        (re.compile(package + ".*-" + version + r"-.*\.src.rpm$"),
         "source RPM",              "SRPM-Package"),
        (re.compile(package + ".*-" + version + r"-.*\.rpm$"),
         "binary RPM",              "RPM-Package"),
        (re.compile(package + ".*-" + version + r"-.*\.deb$"),
         "Debian package",          "Debian-Package"),
        )
    deliverables = []
    for filename in os.listdir("."):
        for (pattern, explanation, tag) in deliverable_types: 
            if pattern.search(filename):
                deliverables.append((filename, explanation, tag))
    if options.verbose:
        print "Deliverables:", " ".join(map(lambda x: x[0], deliverables))

    #
    # Might be time to dump
    #
    if options.nobuild:
        for variable in ('destinations', 'whoami', 'date', 
                         'package', 'website', 'project_tags', 
                         'freshmeat_name', 'berlios_name', 'sourceforge_name',
                         'summary', 'tag_template', 'tag_message'):
            print "%s = %s" % (variable, `eval(variable)`)
        for variable in ('description', 'changelog', 'lastchange', 'mailtemplate', 'indextemplate'):
            if not eval(variable):
                print "No %s" % variable
            else:
                print "%s = <<EOF\n%sEOF" % (variable, eval(variable))
        raise SystemExit, 0
    #
    # Build deliverables
    #

    # Sanity checks
    if not filter(versioned, map(lambda (f, e, t): f, deliverables)):
        croak("no deliverables with versions!")
    if not destinations:
        croak("the Destinations list is empty; nothing to do.")

    if options.verbose:
        print "shipper: sanity checks passed"

    # Compute other deliverables, we need this even if not rebuilding
    # the index. Includes anything with an HTML, Javascript, or CSS
    # extension.
    for filename in glob.glob('*.html')+glob.glob('*.xhtml')+glob.glob('*.js')+glob.glob('*.css'):
        if filename == 'index.html':
            continue
        stem = filename[:-4]
        for ext in ("man", "1", "2", "3", "4", "5", "6", "7", "8", "9", "xml"):
            if os.path.exists(stem + ext):
                explanation = "HTML rendering of " + stem + ext
                break
        else:
            explanation = "HTML page."
        deliverables.append((filename, explanation, None))

    # If a web page doesn't already exist, but the index template
    # variable is nonempty (which is the default) make one.  
    if website and indextemplate and options.makeindex:
        make_index_page(deliverables)
        # Now that the web page has been generated, it can add
        # itself to the deliverables without having it show up in
        # the resource table.
        deliverables.append(("index.html", "index web page", None))

    # The freshmeat announcement
    if 'freshmeat' in destinations and not os.path.exists("SHIPPER.FRESHMEAT"):
        print "# Building SHIPPER.FRESHMEAT..."
        if not website:
            print "# Can't announce to freshmeat without a primary website!"
            destinations.remove("freshmeat")
        elif not lastchange:
            print "# Can't announce to freshmeat without a changes field!"
            destinations.remove("freshmeat")
        else:
            while True:
                focus = raw_input("# freshmeat.net release focus (? for list): ")
                if focus == '?':
                    i = 0
                    for f in freshmeat_focus_types:
                        print "%d: %s" % (i, f)
                        i += 1
                elif focus in "0123456789":
                    focus = freshmeat_focus_types[int(focus)]
                    print "# OK:", focus
                    break
                elif focus.lower() in map(lambda x: x.lower(), freshmeat_focus_types):
                    break
                else:
                    croak("not a valid freshmeat.net release focus!")
            # Download directory has to be computed differently at
            # special destinations
            if website.find("berlios"):
                download = "http://download.berlios.de/"+(berlios_name or package)
            if website.find("sourceforge"):
                download = "http://sourceforge.net/projects/%s/files/%s/%s" % (
                    sourceforge_name,
                    sourceforge_name,
                    version)
            else:
                download = website
            ofp = open("SHIPPER.FRESHMEAT", "w")
            ofp.write("Project: %s\n" % (freshmeat_name or package))
            ofp.write("Version: %s\n" % version)
            if project_tags:
                ofp.write("Project-Tag-List: %s\n" % project_tags)
            ofp.write("Release-Focus: %s\n" % focus)
            ofp.write("Website-URL: %s\n" % website)
            for (f, e, s) in deliverables:
                if s:
                    ofp.write("%s-URL: %s\n" % (s, os.path.join(download, f)))
            # freshmeat.net doesn't like bulleted entries.
            freshmeatlog = map(lambda s: s.lstrip(), lastchange.split("\n"))
            ofp.write("\n" + "\n".join(freshmeatlog))
            ofp.close()

    # Finally, email notification
    maildests = filter(lambda x: x.startswith("mailto:"), destinations)
    if maildests and not os.path.exists("SHIPPER.EMAIL"):
        print "# Building SHIPPER.EMAIL..."
        ofp = open("SHIPPER.EMAIL", "w")
        ofp.write("To: " + ", ".join(map(lambda x: x[7:], maildests)) + "\n")
        ofp.write(mailtemplate % globals())
        ofp.close()

    #
    # Now actually ship
    #

    # Compute final deliverables
    all_deliverables = map(lambda x: x[0], deliverables)
    download_deliverables = filter(versioned,
                                   map(lambda x: x[0], deliverables))
    web_deliverables = filter(lambda f: not versioned(f),
                              map(lambda x: x[0], deliverables))

    # Shipping methods for public destinations.
    def freshmeat():
        freshmeat_ship("SHIPPER.FRESHMEAT")
    def berlios():
        upload("ftp://ftp.berlios.de/incoming", download_deliverables)
        berlios_webdir = \
                       "shell.berlios.de:/home/groups/" \
                       + (berlios_name or package) \
                       + "/htdocs"
        upload(berlios_webdir, web_deliverables, subdir="")
    def sourceforge():
        upload_or_die("rsync -avP -e ssh %s %s,%s@frs.sourceforge.net:/home/frs/project/%s/%s/%s/%s/" % (
            " ".join(download_deliverables),
            sourceforge_userid, 
            sourceforge_name,
            sourceforge_name[:1],
            sourceforge_name[:2],
            sourceforge_name,
            version))
    hardwired = ("freshmeat", "berlios", "sourceforge")

    if options.verbose:
        print "Destinations: ", ", ".join(destinations)

    # OK, ship everything.
    for destination in destinations:
        if destination in hardwired:
            print "# Shipping to public destination", destination
            eval(destination + "()")
        elif destination.startswith("ftp:"):
            upload(destination, download_deliverables)
        elif destination.startswith("mailto:"):
            dest = destination[7:]
            print "# Mailing to %s" % dest
            content = open("SHIPPER.EMAIL").read()
            if options.upload:
                server = smtplib.SMTP('localhost')
                server.sendmail(whoami, dest, content)
                server.quit()
            else:
                print "mail %s <<EOF" % dest
                print content
                print "EOF"
        elif destination not in hardwired:
            upload(destination, all_deliverables)

    # Shipping has succeeded.
    if options.vcstag and tag_template and tag_message:
        tagname = tag_template % version
        tag_message = tag_message % version

        # If we're in the trunk of an SVN repository, we want to tag
        # what just got shipped as an external release (unless the tag
        # already exists, or the user suppressed this behavior by
        # setting tag_template to None or "").
        if os.path.basename(os.getcwd())=='trunk' and os.path.exists(".svn"):
            print "# This is a Subversion trunk directory..."
            if os.path.exists("../tags"):
                print "# I see a peer tags directory..."
                if os.path.exists("../tags/" + tagname):
                    print "# This release has aleady been tagged."
                else:
                    print "# I will copy and tag this release as %s." % tagname
                    upload_or_die("cd .. && svn copy trunk tags/%s && svn -m '%s' commit" % (tagname, tag_message))
        # Ditto for git.
        if os.path.exists(".git"):
            print "# This is a git repository..."
            if os.path.exists(".git/refs/tags/" + tagname):
                print "# This release has already been tagged."
            else:
                print "# I will tag this release as %s." % tagname
                upload_or_die("git tag -a %s -m '%s'" % (tagname, tag_message))
    print "# Done"
except KeyboardInterrupt:
    print "# Bye!"

# The following sets edit modes for GNU EMACS
# Local Variables:
# mode:python
# End:
