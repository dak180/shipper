#!/usr/bin/env python
#
# shipper -- a tool for shipping software

import sys, os, readline, re, commands, time, glob, optparse, stat, email

#
# State variables
#
destinations = []	# List of remote directories to update
whoami = None		# Who am I? (Used for FTP logins)
date = None		# User has not yet set a date
package = None   	# Nor a package name
website = None		# Nor a home page
arch = None       	# The machine architecture
project_tags = None  	# Keywords for tagging
freshmeat_name = None	# Name of the project on Freshmeat
berlios_name = None	# Name of the project on derlios,de
changelog = None	# Project changelog
lastchange = None  	# Last entry in changelog
summary = None   	# One-line summary of the package
description = None	# Nor a description
webfiles = []		# Extra webfiles

# Policy choices
tag_template = "%s"
tag_message = "Tagged for external release %s"

indextemplate = """
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html>
<head>
<link rel='stylesheet' href='/~esr/sitestyle.css' type='text/css' />
<meta name='description' content='Resource page for %(package)s' />
<meta name='generator' content='shipper' />
<meta name='MSSmartTagsPreventParsing' content='TRUE' />
<title>Resource page for %(package)s %(version)s</title>
</head>
<body>

<h1>Resource page for %(package)s %(version)s</td></h1>

<p>%(description)s</p>

<br />
%(resourcetable)s
<br />

<p>Last modified %(date)s.</p>

</div>
</body>
</html>
"""
mailtemplate = """Subject: Announcing release %(version)s of %(package)s

Release %(version)s of %(package)s is now available at:

	%(website)s

Here are the most recent changes:

%(lastchange)s
--
                             shipper, acting for %(whoami)s
"""

# It's unpleasant that we have to include these here, but
# the freshmeat release focus has to be validated even if the
# user is offline and the XML-RPC service not accessible.
freshmeat_focus_types = (
"N/A",
"Initial freshmeat announcement",
"Documentation",
"Code cleanup",
"Minor feature enhancements",
"Major feature enhancements",
"Minor bugfixes",
"Major bugfixes",
"Minor security fixes",
"Major security fixes",
)

def croak(msg):
    sys.stderr.write("shipper: " + msg + "\n")
    sys.exit(1)

#
# Shipping methods
#

def do_or_die(cmd):
    "Either execute a command or fail noisily, letting output go to stdout."
    if options.verbose:
        print "***", cmd
    if os.system(cmd):
        croak("command '%s' failed!" % cmd)

def trap_or_die(cmd):
    "Either execute a command or fail noisily, capturing output."
    if options.verbose:
        print "***", cmd
    (status, output) =  commands.getstatusoutput(cmd)
    if status:
        croak("command '%s' failed!" % cmd)
    else:
        return output

def upload_or_die(cmd):
    if options.noupload:
        print cmd
    else:
        do_or_die(cmd)

def upload(destination, files, subdir=None):
    # Upload a file via ftp or sftp, handles
    if subdir == None:
        subdir=package
    print "# Uploading to %s" % destination
    files = filter(os.path.exists, files)
    if destination.startswith("ftp://"):
        destination = destination[6:].split("/")
        host = destination.pop(0)
        directory = "/".join(destination)
        (realname, address) = email.utils.parseaddr(whoami)
        commands = ["lftp\n", "open -u anonymous," + address + " " + host + "\n"]
        if directory:
            commands.append("cd " + directory + "\n")
        commands.append("mput " + " ".join(files) + "\n")
        commands.append("close\n")
        if options.noupload:
            print "".join(commands)
        else:
            pfp = os.popen(commands.pop(0), "w")
            pfp.writelines(commands)
            pfp.close()
    elif destination.find("::") > -1:
        upload_or_die("rsync " + " ".join(files) + " " + destination)
    elif destination.find(":") > -1:
        (host, directory) = destination.split(":")
        for file in files:
            # This is a really ugly way to deal with the problem
            # of write-protected files in the remote directory.
            # Unfortunately, sftp(1) is rather brain-dead -- no
            # way to ignore failure on a remove, and refuses to
            # do renames with an obscure error message.
            remote = os.path.join(directory, subdir, os.path.basename(file))
            upload_or_die("scp " + file + " " + host + ":" + remote+".new;")
            upload_or_die("ssh %s 'mv -f %s.new %s'" % (host, remote, remote))
    else:
        sys.stderr.write("Don't know what to do with destination %s!\n" % destination)

def freshmeat_ship(manifest):
    "Ship a specified update to freshmeat."
    if options.verbose:
        print "Announcing to freshmeat..."
    upload_or_die("freshmeat-submit <" + manifest[0])

def make_index_page(deliverables, version):
    "Make index page, listing specified set deliverables, if it doesn't exist."
    print "# Building %s..." % version
    global resourcetable
    resourcetable = '<table border="1" align="center" summary="Downloadable resources">\n'
    for (file, explanation) in deliverables:
        resourcetable += "<tr><td><a href='%s'>%s</a></td><td>%s</td></tr>\n" % (file,file,explanation)
    resourcetable += "</table>"
    # OK, now build the index page itself
    ofp = open(version, "w")
    ofp.write(indextemplate % globals())
    ofp.close()

#
# Metadata extraction
#

def grep(pattern, file):
    "Mine for a specified pattern in a file."
    fp = open(file)
    try:
        while True:
            line = fp.readline()
            if not line:
                return None
            m = re.search(pattern, line)
            if m:
                return m.group(1)
    finally:
        fp.close()
    return None

class Specfile:
    def __init__(self, filename):
        self.filename = filename
        self.type = None
        if filename.endswith(".spec"):
            self.type = "RPM"
            self.package = self.extract("Name")
            self.version = self.extract("Version")
            self.website = self.extract("URL")
            self.summary = self.extract("Summary")
            self.arch = self.extract("BuildArch") or commands.getoutput("rpm --showrc | sed -n '/^build arch/s/.* //p'")
            self.description = self.rpm_get_multiline("description")
            changelines = self.rpm_get_multiline("changelog").split("\n")
            while not changelines[-1] or changelines[-1].startswith("# "):
                changelines.pop()
            self.changelog = "\n".join(changelines)
        elif filename == "control":
            self.type = "deb"
            self.name = self.extract("Package")
            self.version = self.extract("Version").split("-")[0]
            self.website = self.extract("XBS-Website")
            self.summary = self.extract("Description")
            self.arch = self.extract("Architecture")
            if not self.arch:
                croak("this control file lacks an Architecture field")
            # FIXME: parse Debian description entries and changelog file
            self.description = self.changelog = None
    def extract(self, fld):
        "Extract a one-line field, possibly embedded as a magic comment."
        if self.type == "RPM":
            return grep("^#?"+fld+":\s*(.*)", self.filename)
        elif self.type == "deb":
            return grep("^(?:XBS-)?"+fld+": (.*)", self.filename)
    def rpm_get_multiline(self, fieldname):
        "Grab everything from leader line to just before the next leader line."
        global desc
        fp = open(self.filename)
        desc = ""
        gather = False
        while True:
            line = fp.readline()
            if not line:
                break
            # Pick up fieldnames *without* translation options.
            if line.strip() == "%" + fieldname:
                gather = True
                continue
            elif line[0] == "%":
                gather = False
            if gather:
                desc += line
        fp.close()
        if desc:
            return desc.strip() + "\n"
        else:
            return None
#
# Main sequence
#

try:
    #
    # Process options
    #

    parser = optparse.OptionParser(usage="%prog: [-n] [-f] [-v]")
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="print progress messages to stdout")
    parser.add_option("-n", "--noupload",
                      action="store_true", dest="noupload", default=False,
                      help="don't do uploads, just build deliverables")
    parser.add_option("-N", "--nobuild",
                      action="store_true", dest="nobuild", default=False,
                      help="dump configuration only, no builds or uploads")
    (options, args) = parser.parse_args()

    #
    # Extract metadata and compute control information
    #

    def disable(s): destinations.remove(s)

    # Security check, don't let an attacker elevate privileges 
    def securecheck(file):
        if stat.S_IMODE(os.stat(file).st_mode) & 00002:
            croak("%s must not be world-writeable!" % file)

    # Read in variable overrides
    securecheck(".")
    home_profile = os.path.join(os.getenv('HOME'), ".shipper")
    if os.path.exists(home_profile):
        securecheck(home_profile)
        execfile(home_profile)
    here_profile = ".shipper"
    if os.path.exists(here_profile):
        securecheck(here_profile)
        execfile(here_profile)

    # Set various sensible defaults
    if not whoami:
        croak("please set whoami in your .shipper file.")

    # Where to get the metadata
    specfiles = glob.glob("*.spec")
    if len(specfiles) == 1:
        metadata = Specfile(specfiles[0])
    elif os.path.exists("control"):
        metadata = Specfile("control")
    else:
        croak("must be exactly one RPM or dpkg specfile in the directory!")

    # Get the package name
    if not package:
        package = metadata.package
    if not package:
        croak("can't get package name!")

    # Extract the package version from the specfile or Makefile
    specvers = metadata.version
    makevers = None
    makefile = None
    if os.path.exists("Makefile"):
        makefile = "Makefile"        
    if os.path.exists("makefile"):
        makefile = "makefile"
    if makefile:
        makevers = grep("^VERS[A-Z]* *= *(.*)", makefile)
        # Maybe it's a shell command intended to extract version from specfile
        if makevers and makevers[0] == '$':
            makevers = commands.getoutput(makevers[7:-1])
    if makevers and specvers != makevers:
        croak("specfile version %s != Makefile version %s"%(specvers,makevers))
    elif specvers == None:
        croak("can't get package version")
    elif specvers[0] not in "0123456789":
        croak("package version %s appears garbled" % specvers)
    else:
        version = specvers

    # Specfiles may set their own destinations
    local_destinations = metadata.extract("Destinations")
    if local_destinations:
        local_destinations = map(lambda x: x.strip(), local_destinations.split(","))
        destinations += local_destinations

    print"# Uploading version %s of %s" % (version, package)

    # Extract remaining variables for templating
    if not website:
        website = metadata.website
    if not date:
        date = time.asctime()
    if not summary:
        summary = metadata.summary
    if not description:
        description = metadata.description
    if not arch:
        arch = metadata.arch
    if not project_tags:
        project_tags = metadata.extract("Project-Tags")
    if not freshmeat_name:
        freshmeat_name = metadata.extract("Freshmeat-Name")
    if not berlios_name:
        berlios_name = metadata.extract("Berlios-Name")
    resourcetable = ""

    if options.verbose:
        print "shipper: variable extraction finished"

    # Finally, derive the change log and lastchange entry;
    # we'll need the latter for freshmeat.net
    freshmeat_lastchange = lastchange = changelog = None
    # ChangeLog, if present, takes precedence;
    # we assume if both are present that the specfile log is about packaging.
    if os.path.exists("ChangeLog"):
        if options.verbose:
            print "shipper: I see a ChangeLog file"
        ifp = open("ChangeLog", "r")
        changelog = ifp.read()
        ifp.close()
        lastchange = ""
        for line in changelog.split("\n"):
            if line.strip() or not "*" in lastchange:
                lastchange += line + "\n"
            else:
                break
        # freshmeat.net doesn't like bulleted items in a changes field.
        freshmeat_lastchange = "See the ChangeLog file for recent changes."
    elif metadata.changelog:
        if options.verbose:
            print "shipper: I see changelog metadata"
        changelog = metadata.changelog
        lastchange = ""
        for line in changelog.split("\n"):
            if not lastchange and (not line.strip() or line[0] == '*'):
                continue
            elif line.strip():
                lastchange += line + "\n"
            else:
                break
        # This usually produces a lastchange entry that freshmeat will take.
        freshmeat_lastchange = lastchange

    if options.verbose:
        print "shipper: starting deliverables computation"

    #
    # Now compute the names of deliverables
    #

    # These are all potential deliverable files that include the version number
    tarball   = package + "-" + version + ".tar.gz"
    binrpm    = package + "-" + version + "-1." + arch + ".rpm"
    srcrpm    = package + "-" + version + "-1.src.rpm"
    zipfile   = package + "-" + version + ".zip"

    # Map web deliverables to explanations for the resource table
    # Stuff not included here: SHIPPER.EMAIL, SHIPPER.FRESHMEAT.
    web_only_stock_deliverables = [
        ("README",	"roadmap file"),
        ("ChangeLog",	"change log"),
        ("CHANGES",	"change log"),		# Generated
        ("NEWS",	"Project news"),
        ("HISTORY",	"Project history"),
        ("BUGS",	"Known bugs"),
        ("TODO",	"To-do file"),
        ]
    download_stock_deliverables = [
        (tarball,	"source tarball"),
        (zipfile,   	"ZIP archive"),
        ]

    #
    # Might be time to dump
    #
    if options.nobuild:
        for variable in ('destinations', 'whoami', 'date', 
                         'package', 'website', 'arch', 'project_tags', 
                         'freshmeat_name', 'berlios_name', 'summary',
                         'webfiles', 'tag_template', 'tag_message'):
            print "%s = %s" % (variable, `eval(variable)`)
        for variable in ('description', 'changelog', 'lastchange', 'mailtemplate', 'indextemplate'):
            if not eval(variable):
                print "No %s" % variable
            else:
                print "%s = <<EOF\n%sEOF" % (variable, eval(variable))
        sys.exit(0)
    #
    # Build deliverables
    #

    # Sanity checks
    if not os.path.exists(tarball):
        croak("no tarball %s!" % tarball)
    if metadata.type == "RPM" and not metadata.extract("BuildRoot"):
        croak("specfile %s doesn't have a BuildRoot!" % metadata.filename)
    if not destinations:
        croak("the Destinations list is empty; nothing to do.")

    if options.verbose:
        print "shipper: sanity checks passed"

    try:
        delete_at_end = []
        rpmlist = []

        def newer(f1, f2):
            return os.path.exists(f1) and (os.stat(f1).st_mtime > os.stat(f2).st_mtime)

        #
        # Generate RPMs first, the list of these is variable and needs to go
        # into deliverables.
        #
        print "# Building RPMs..."
        output = trap_or_die("rpmbuild -ta %s; cp ~/rpmbuild/RPMS/*/*.rpm ~/rpmbuild/SRPMS/*.rpm .; rm -fr ~/rpmbuild" % tarball)
        if options.verbose:
            sys.stdout.write(output)
        # Extract names of RPMs actually generated.
        # Later in the code we presume that binrpm matches one
        # of these, the base-subpackage binary RPM.  Others
        # might be, for example, a -devel RPM.
        for line in output.split("\n"):
            if line.startswith("Wrote: "):
                rpm = os.path.basename(line[6:])
                delete_at_end.append(rpm)
                rpmlist.append(rpm)
        if options.verbose:
            print "RPMS:", ", ".join(rpmlist)

        # Next the CHANGES file.  Build this only if (a) there is no
        # ChangeLog, and (b) there is a specfile %changelog.        
        if not os.path.exists("ChangeLog") and changelog:
            print "# Building CHANGES..."
            ofp = open("CHANGES", "w")
            ofp.write("                     Changelog for " + package + "\n\n")
            ofp.write(changelog)
            ofp.close()
            delete_at_end.append("CHANGES")

        #
        # Compute the deliverables, we need this even if not rebuilding
        # the index.
        #
        # Anything in the list of standard download deliverables is eligible.
        download_only_deliverables = []
        for (file, explanation) in download_stock_deliverables:
            if os.path.exists(file):
                download_only_deliverables.append((file, explanation))
        # So are any RPMS we generated
        for rpm in rpmlist:
            if rpm == binrpm:
                download_only_deliverables.append((rpm, "installable binary RPM"))
            elif rpm == srcrpm:
                download_only_deliverables.append((rpm, "source RPM"))
            else:
                download_only_deliverables.append((rpm, "auxiliary RPM"))

        # Anything in the list of standard web deliverables is eligible.
        web_only_deliverables = []
        for (file, explanation) in web_only_stock_deliverables:
            if os.path.exists(file):
                web_only_deliverables.append((file, explanation))
        # So is anything with an HTML, Javascript, or CSS extension
        for file in glob.glob('*.html')+glob.glob('*.js')+glob.glob('*.css'):
            if file == 'index.html':
                continue
            stem = file[:-4]
            for ext in ("man", "1", "2", "3", "4", "5", "6", "7", "8", "9", "xml"):
                if os.path.exists(stem + ext):
                    explanation = "HTML rendering of " + stem + ext
                    break
            else:
                explanation = "HTML page."
            web_only_deliverables.append((file, explanation))
        # Configuration variable can specify more
        if webfiles:
            web_only_deliverables += webfiles

        # If a web page doesn't already exist, make two versions.
        # One has a resource table listing all deliverables, for ordinary
        # websites. The other one omits downloadables; this is for sites
        # like berlios and sourceforge, where downloads live on a separate
        # server.
        if website and not os.path.exists("index.html"):
            make_index_page(download_only_deliverables + web_only_deliverables,
                            "index.html-downloads")
            delete_at_end.append("index.html-downloads")
            make_index_page(web_only_deliverables, "index.html-nodownloads")
            delete_at_end.append("index.html-nodownloads")
            delete_at_end.append("index.html")
            upload_or_die("ln -f index.html-downloads index.html")

        # Now that the web page has been generated, it can add itself to the
        # deliverables without having it show up in the resource table.
        if os.path.exists("index.html"):
            web_only_deliverables.append(("index.html", "index web page"))

        # The freshmeat announcement
        if 'freshmeat' in destinations:
            print "# Building SHIPPER.FRESHMEAT..."
            if not website:
                print "# Can't announce to freshmeat without a primary website!"
            elif not lastchange:
                print "# Can't announce to freshmeat without a changes field!"
            else:
                while True:
                    focus = raw_input("# freshmeat.net release focus (? for list): ")
                    if focus == '?':
                        i = 0
                        for f in freshmeat_focus_types:
                            print "%d: %s" % (i, f)
                            i += 1
                    elif focus in "0123456789":
                        focus = freshmeat_focus_types[int(focus)]
                        print "# OK:", focus
                        break
                    elif focus.lower() in map(lambda x: x.lower(), freshmeat_focus_types):
                        break
                    else:
                        croak("not a valid freshmeat.net release focus!")
                # Download directory has to be computed differently at
                # special destinations
                if website.find("berlios"):
                    download = "http://download.berlios.de/"+(freshmeat_name or package)
                else:
                    download = website
                ofp = open("SHIPPER.FRESHMEAT", "w")
                ofp.write("Project: %s\n" % (freshmeat_name or package))
                ofp.write("Version: %s\n" % version)
                if project_tags:
                    ofp.write("Project-Tags: %s\n" % project_tags)
                ofp.write("Release-Focus: %s\n" % focus)
                ofp.write("Website-URL: %s\n" % website)
                if os.path.exists(tarball):
                    ofp.write("Tar/GZ-URL: %s\n" % os.path.join(download,tarball))
                if os.path.exists(zipfile):
                    ofp.write("Zip-URL: %s\n" % os.path.join(download, zipfile))
                if os.path.exists("CHANGES"):
                    ofp.write("Changelog-URL: %s\n" % os.path.join(website, "CHANGES"))
                if os.path.exists(binrpm):
                    ofp.write("RPM-URL: %s\n" % os.path.join(download, binrpm))
                # freshmeat.net doesn't like bulleted entries.
                freshmeatlog = lastchange[2:].replace("\n  ", "\n")
                ofp.write("\n" + freshmeatlog)
                ofp.close()
                delete_at_end.append("SHIPPER.FRESHMEAT")

        # Finally, email notification
	maildests = filter(lambda x: x.startswith("mailto:"), destinations)
        if maildests:
            print "# Building SHIPPER.EMAIL..."
            ofp = open("SHIPPER.EMAIL", "w")
	    ofp.write("To: " + ", ".join(map(lambda x: x[7:], maildests)) + "\n")
            ofp.write(mailtemplate % globals())
            ofp.close()
            delete_at_end.append("SHIPPER.FRESHMEAT")

        #
        # Now actually ship
        #

        # Compute final deliverables
        all_deliverables = map(lambda x: x[0], download_only_deliverables + web_only_deliverables)
        download_deliverables = map(lambda x: x[0], download_only_deliverables)
        web_deliverables = map(lambda x: x[0], web_only_deliverables)

        # Shipping methods for public destinations.
        def freshmeat():
            freshmeat_ship(("SHIPPER.FRESHMEAT",))
        def berlios():
            upload("ftp://ftp.berlios.de/incoming", download_deliverables)
            if os.path.exists("index.html-nodownloads"):
                upload_or_die("ln -f index.html-nodownloads index.html")
            berlios_webdir = \
                           "shell.berlios.de:/home/groups/" \
                           + (berlios_name or package) \
                           + "/htdocs"
            upload(berlios_webdir, web_deliverables, subdir="")
        hardwired = ("freshmeat", "berlios")

        # OK, ship everything.
        for destination in destinations:
            if destination in hardwired:
                print "# Shipping to public destination", destination
                eval(destination + "()")
            elif destination.startswith("ftp:"):
                upload(destination, download_deliverables)
            elif destination.startswith("mailto:"):
                print "# Mailing to %s" % destination[7:]
                command = "sendmail -i -oem -f %s %s <SHIPPER.EMAIL" % (whoami, destination[7:])
                if options.noupload:
                    print command
                else:
                    do_or_die(command)
            elif destination not in hardwired:
                upload_or_die("ln -f index.html-downloads index.html")
                upload(destination, all_deliverables)

        # Shipping has succeeded.
        if tag_template and tag_message:
            tagname = tag_template % version
            tag_message = tag_message % version

            # If we're in the trunk of an SVN repository, we want to tag
            # what just got shipped as an external release (unless the tag
            # already exists, or the user suppressed this behavior by
            # setting subversion_tag_template to None or "").
            if os.path.basename(os.getcwd())=='trunk' and os.path.exists(".svn"):
                print "# This is a Subversion trunk directory..."
                if os.path.exists("../tags"):
                    print "# I see a peer tags directory..."
                    if os.path.exists("../tags/" + tagname):
                        print "# This release has aleady been tagged."
                    else:
                        print "# I will copy and tag this release."
                        upload_or_die("cd .. && svn copy trunk tags/%s && svn -m '%s' commit" % (tagname, tag_message))
            if os.path.exists(".git"):
                print "# This is a git repository..."
                if os.path.exists(".git/refs/tags/" + tagname):
                    print "# This release has aleady been tagged."
                else:
                    print "# I will tag this release."
                    upload_or_die("git tag -a %s -m '%s'" % (tagname, tag_message))
    finally:
        cleanup = "rm -f " + " ".join(delete_at_end)
        if options.noupload:
            print cleanup
        else:
            for file in delete_at_end:
                os.system(cleanup)
    print "# Done"
except KeyboardInterrupt:
    print "# Bye!"

# The following sets edit modes for GNU EMACS
# Local Variables:
# mode:python
# End:
