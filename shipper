#!/usr/bin/env python
#
# shipper -- a tool for shipping software
#
# Requires Python 2.72 or later.

import sys, os, re, commands, time, tempfile, shutil
import glob, optparse, stat, email.utils

shipper_version = "0.17"

#
# State variables
#
# Note: When you add a variable to this set, be sure also to tweak
# the state-dumping code.
#
destinations = []	# List of remote directories to update
whoami = None		# Who am I? (Used for FTP logins and mail signatures)
gittip_id = None	# My name on gittip.com
date = None		# User has not yet set a date
package = None   	# Nor a package name
website = None		# Nor a home page
irc_channel = None	# Nor an IRC channel
project_tags = None  	# Keywords for tagging
freecode_name = None	# Name of the project on Freecode
berlios_name = None	# Name of the project on Berlios
savannah_id = None      # User ID to use for CVS on Savannah
savannah_name = None	# Name of the project on savannah.org (non-gnu)
gitorious_url = None    # URL of the project on gitorious
github_url = None	# URL of the project on github
sourceforge_name = None # Name of the project on sourceforge.net
sourceforge_folder = "" # Subfolder for file releases 
ohloh_url = ""		# Where the Ohloh stats live
summary = None   	# One-line summary of the package
webdir = None           # Web directory to be mirrored to a project site
web_extras = None	# Extra web deliverables
logo = ""               # Project logo
tag_template = None	# How to tag releases
tag_message = "Tagged for external release %(version)s"
irc_message = "Version %(version)s of %(package)s has just shipped."
#Stuff after this point is multiline
description = None	# Multiline description
changelog = None	# Project changelog
lastchange = None  	# Last entry in changelog
extralines = ""         # Extra lines for HTML template

html_target = None	# Name to template a page to
html_template = """
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html>
<head>
<meta name='description' content='Resource page for %(package)s' />
<meta name='generator' content='shipper' />
<meta name='description' content="%(summary)s"/>
<title>Resource page for %(package)s %(version)s</title>
</head>
<body>

<table width='100%%' cellpadding='0' summary='Canned page header' bgcolor='#ddd'>
<tr>
<td><h2>Resource page for %(package)s %(version)s</h2></td>
<td align="center">%(centertext)s</td>
<td align='right'><h2>%(date)s</h2></td>
</tr>
</table>


<h1>Resource page for %(package)s %(version)s</td></h1>

%(description)s

<br />
%(resourcetable)s
<br />

%(extralines)s
$(gittip)s

<p>Last modified %(date)s.</p>

</div>
</body>
</html>
"""

mail_template = """Subject: Announcing release %(version)s of %(package)s

Release %(version)s of %(package)s is now available at:

	%(website)s

Here are the most recent changes:

%(lastchange)s
--
                             shipper, acting for %(whoami)s
"""

def croak(msg):
    sys.stderr.write("shipper: " + msg + "\n")
    sys.exit(1)

#
# Shipping methods
#

def upload(dest, files, subdir=None):
    "Upload a file via ftp or scp."
    if subdir == None:
        subdir = package
    files = [x for x in files if os.path.exists(x)]
    if dest.startswith("ftp://"):
        dest = dest[6:].split("/")
        host = dest.pop(0)
        directory = "/".join(dest)
        upcmds = ["lftp\n", "open -u anonymous," + myaddress + " " + host + "<<'INAGADADAVIDA'\n"]
        if directory:
            upcmds.append("cd " + directory + "\n")
        upcmds.append("mput " + " ".join(files) + "\n")
        upcmds.append("close\n")
        upcmds.append("INAGADADAVIDA\n")
        print("".join(upcmds))
    elif dest.find(":") > -1:
        (host, directory) = dest.split(":")
        for fn in files:
            # Requires your files to be writeable by you - maybe not so if they
            # were RCSed but not locked! If they are, the -p option to scp
            # will set that permission on the remote host and allow you to
            # update the files with scp later.
            remote = os.path.join(directory, subdir, os.path.basename(fn))
            print("scp -p " + fn + " " + host + ":" + remote)
    else:
        sys.stderr.write("Don't know what to do with destination %s!\n" % dest)

def make_templated_page(deliverables, substitutions, outfile):
    "Make templated page, listing specified deliverables."
    global extralines
    substitutions = substitutions.copy()
    resourcetable = '<table border="1" align="center" summary="Downloadable resources">\n'
    for (ifile, explanation, __tag, big) in deliverables:
        if big:
            indurl = download
        else:
            indurl = website
        indurl = os.path.join(indurl, ifile)
        resourcetable += "<tr><td><a href='%s'>%s</a></td><td>%s</td></tr>\n" % (indurl, ifile, explanation)
    resourcetable += "</table>"
    if gitorious_url:
        extralines += "<p>The project repository is on <a href='%s'>gitorious</a>.</p>\n" % \
                      gitorious_url
    if github_url:
        extralines += "<p>The project repository is on <a href='%s'>github</a>.</p>\n" % \
                      github_url
    if ohloh_url:
        extralines += "<p>Project statistics are available at <a href='%s'>Ohloh</a>.</p>\n" % \
                      ohloh_url
    if irc_channel:
        if ',' in irc_channel:
            extralines += '<p>There are project IRC channels:'
            extralines += irc_channel
            extralines += '</p>\n'
        else:
            extralines += '<p>There is a project <a href="%s">IRC channel</a>.</p>\n' % irc_channel
    # Handle the old name of freecode.com for backwards compatibility.
    if 'freecode' in destinations or 'freshmeat' in destinations:
        extralines += "<p>There is a Freecode <a href='http://freecode.com/projects/%s'>%s page</a>.</p>\n" % \
                      (freecode_name, freecode_name)
    if gittip_id:
        extralines += "<p>If you appreciate this code (and especially if you "
        extralines += "make money by using it) please "
        extralines += "<a href='http://gittip.com/%s'>" % gittip_id
        extralines += "leave me a tip on Gittip</a>.</p>"
    centertext = ""
    if "logo" in substitutions and substitutions["logo"]:
        centertext = '<img src="%s"/>' % substitutions["logo"]
    substitutions["description"] = "<p>" + substitutions["description"].replace("\n\n", "</p>\n\n<p>") + "</p>"
    substitutions.update(locals())
    # OK, now build the templated page itself
    print("cat >%s <<'INAGADADAVIDA'" % outfile)
    print(html_template % substitutions)
    print "INAGADADAVIDA\n"

#
# Metadata extraction
#

def grep(regexp, fp):
    "Mine for a specified regexp in a file."
    # Note: this blank-strips its output!
    fp = open(fp)
    try:
        while True:
            line = fp.readline()
            if not line:
                return None
            m = re.search(regexp, line)
            if m:
                return m.group(1).strip()
    finally:
        fp.close()
    return None

class Specfile:
    def __init__(self, filename):
        self.filename = filename
        self.type = None
        if filename.endswith(".spec"):
            self.type = "RPM"
            self.package = self.extract("Name")
            self.version = self.extract("Version")
            self.website = self.extract("URL")
            self.summary = self.extract("Summary")
            self.tag_template = self.extract("Tag-Template")
            self.tag_message = self.extract("Tag-Message")
            self.irc_message = self.extract("IRC-Message")
            self.description = self.rpm_get_multiline("description")
            self.web_extras = self.extract("Web-Extras")
            self.html_target = self.extract("HTML-Target")
            last = ""
            state = 0
            for line in open(self.filename):
                if state == 0:
                    if line.startswith("%changelog"):
                        state = 1
                        continue
                elif state == 1:
                    # Skip first line of entry
                    state = 2
                    continue
                elif state == 2:
                    if not line.strip():
                        break
                    else:
                        if line.strip().startswith("-"):
                            line = line.lstrip()[1:]
                        last += line
            if last:
                self.lastchange = last
            else:
                self.lastchange = None
        elif filename == "control":
            self.type = "deb"
            self.package = self.extract("Package")
            self.version = self.extract("Version")
            if self.version and "-" in self.version:
                self.version = self.version.split("-")[0]
            self.website = self.extract("Homepage")
            self.summary = self.extract("Description")
            self.tag_template = self.extract("XBS-Tag-Template")
            self.tag_message = self.extract("XBS-Tag-Message")
            self.irc_message = self.extract("XBS-IRC-Message")
            self.html_target = self.extract("XBS-HTML-Target")
            fp = open(self.filename)
            desc = ""
            gather = False
            while True:
                line = fp.readline()
                if not line:
                    break
                if line.startswith("Description:"):
                    gather = True
                    desc = line[12:]
                    continue
                elif not line.strip():
                    gather = False
                if gather:
                    if line == " .\n":
                        line = "\n"
                    else:
                        line = line[1:]
                    desc += line
            fp.close()
            if desc:
                self.description = desc.strip() + "\n"
            else:
                self.description = None
            self.web_extras = self.extract("Web-Extras")
            self.lastchange = None
    def extract(self, fld):
        "Extract a one-line field, possibly embedded as a magic comment."
        if self.type == "RPM":
            return grep("^#?"+fld+r":\s*(.*)", self.filename)
        elif self.type == "deb":
            fld = fld.replace('-', '[-_]')
            return grep("^(?:XBS-)?"+fld+": (.*)", self.filename)
    def rpm_get_multiline(self, fieldname):
        "Grab everything from leader line to just before the next leader line."
        fp = open(self.filename)
        data = ""
        gather = False
        while True:
            line = fp.readline()
            if not line:
                break
            # Pick up fieldnames *without* translation options.
            if line.strip() == "%" + fieldname:
                gather = True
                continue
            elif line[0] == "%":
                gather = False
            if gather:
                data += line
        fp.close()
        if data:
            return data.strip() + "\n"
        else:
            return None
#
# Who am I? 
#
def whoami_really():
    "Ask various programs that keep track of who you are who you are."
    # Bazaar version-control system
    (bzrerr, bzrout) = commands.getstatusoutput("bzr config email")
    if bzrerr == 0 and bzrout:
        return bzrout
    # Git version-control system
    (nameerr, nameout) = commands.getstatusoutput("git config user.name")
    (emailerr, emailout) = commands.getstatusoutput("git config user.email")
    if nameerr == 0 and nameout and emailerr == 0 and emailout:
        return "%s <%s>" % (nameout, emailout)
    # Various random configs
    for (fn, mine) in (
        ("~/.hgrc", r"username\s*=\s*(.*)"),                # Mercurial
        ("~/.lynxrc", r"personal_mail_address\s*=\s*(.*)")  # Lynx
        ):
        fn = os.path.expanduser(fn)
        if os.path.exists(fn):
            for line in file(fn):
                m = re.search(mine, line)
                if m:
                    return m.group(1)
    # Out of alternatives
    return None

#
# Main sequence
#

try:
    #
    # Process options
    #

    parser = optparse.OptionParser(usage="%prog: [-u] [-f] [-v]")
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="print progress messages to stdout")
    parser.add_option("-d", "--dump",
                      action="store_true", dest="dump", default=False,
                      help="dump configuration only, no builds or uploads")
    parser.add_option("-x", "--exclude",
                      dest="excluded", default="",
                      help="exclude some shipping targets")
    parser.add_option("-w", "--web-only",
                      action="store_true", dest="webonly", default=False,
                      help="do webspace update only")
    (options, args) = parser.parse_args()

    #
    # Extract metadata and compute control information
    #

    package = os.path.basename(os.getcwd())

    # Security check, don't let an attacker elevate privileges 
    def securecheck(fn):
        if stat.S_IMODE(os.stat(fn).st_mode) & 0o0002:
            croak("%s must not be world-writeable!" % fn)

    # Read in user's profiles
    home_profile = os.path.join(os.getenv('HOME'), ".shipper")
    if os.path.exists(home_profile):
        securecheck(home_profile)
        exec(compile(open(home_profile).read(), home_profile, 'exec'))
    home_profile = os.path.join(os.getenv('HOME'), ".config/shipper")
    if os.path.exists(home_profile):
        securecheck(home_profile)
        exec(compile(open(home_profile).read(), home_profile, 'exec'))

    # User's identity
    if not whoami:
        whoami = whoami_really()
    if not whoami:
        croak("please set whoami in your ~/.config.shipper or ~/.shipper file.")
    (myrealname, myaddress) = email.utils.parseaddr(whoami)
    (myuserid, myhost) = myaddress.split("@")

    # Project metadata
    if os.path.exists("control"):
        metadata = Specfile("control")
    else:
        specfiles = glob.glob("*.spec")
        if len(specfiles) == 1:
            metadata = Specfile(specfiles[0])
        else:
            croak("must be exactly one RPM specfile in the directory!")

    # Shipper-specific project profile
    securecheck(".")
    here_profile = ".shipper"
    if os.path.exists(here_profile):
        securecheck(here_profile)
        exec(compile(open(here_profile).read(), here_profile, 'exec'))

    # Get the package name
    if not package:
        package = metadata.package
    if not package:
        croak("can't get package name!")

    version = metadata.version

    # Specfiles may set their own destinations
    local_destinations = metadata.extract("Destinations")
    if local_destinations:
        local_destinations = [x.strip() for x in local_destinations.split(",")]
        negations = [s for s in local_destinations if s.startswith("~")]
        local_destinations = [s for s in local_destinations if not s.startswith("~")]
        if "~" in negations:
            destinations = local_destinations
        else:
            destinations += local_destinations
            for removable in [s[1:] for s in negations]:
                if removable in destinations:
                    destinations.remove(removable)

    # Hack the destinations variable if need be, might mean we can avoid some
    # builds.
    if options.excluded:
        for excludee in options.excluded.split(","):
            if excludee in destinations:
                destinations.remove(excludee)
            else:
                sys.stderr.write("shipper: %s isn't in the destinations!\n" % excludee)
                raise SystemExit(1)

    # Extract remaining variables for templating
    # Note: When you add a variable here,
    # don't forget to update the dump code down below.
    if not website:
        website = metadata.website
    if not date:
        date = time.asctime()
    if not summary:
        summary = metadata.summary
    if not description:
        description = metadata.description
    if not project_tags:
        project_tags = metadata.extract("Project-Tag-List")
    freecode_name = metadata.extract("Freecode-Name")
    if not freecode_name:
        freecode_name = metadata.extract("Freshmeat-Name")
    if not freecode_name:
        freecode_name = package
    savannah_name = metadata.extract("Savannah-Name")
    if not savannah_name:
        savannah_name = package
    berlios_name = metadata.extract("Berlios-Name")
    if not berlios_name:
        berlios_name = package
    sourceforge_name = metadata.extract("SourceForge-Name")
    if sourceforge_name:
        if "@" in sourceforge_name:
            (sourceforge_userid, sourceforge_name) = sourceforge_name.split("@")
    else:
        sourceforge_name = package
        sourceforge_userid = myuserid
    if metadata.tag_template:
        tag_template = metadata.tag_template
    if metadata.tag_message:
        tag_message = metadata.tag_message
    if metadata.irc_message:
        irc_message = metadata.irc_message
    sourceforge_folder = metadata.extract("SourceForge-Folder")
    gitorious_url = metadata.extract("Gitorious-URL")
    github_url = metadata.extract("Github-URL")
    ohloh_url = metadata.extract("Ohloh-URL")
    irc_channel = metadata.extract("IRC-Channel")
    logo = metadata.extract("Logo")
    webdir = metadata.extract("Web-Directory")
    web_extras = metadata.extract("Web-Extras")
    html_target = metadata.extract("HTML-Target")
    resourcetable = ""

    # Arguments can be variable settings
    for arg in args:
        if arg.count("=") != 1:
            print("shipper: '%s' is not in name=value form." % arg)
            raise SystemExit, 1
        else:
            (name, val) = arg.split("=")
            try:
                exec '%s = "%s"' % (name, val)
            except (SyntaxError, NameError, ValueError):
                print("shipper: ill-formed variable setting at %s" % arg)
                raise SystemExit, 1

    if not options.dump:
        if version == None:
            croak("can't get package version")
        elif version[0] not in "0123456789":
            croak("package version %s appears garbled" % version)

    if options.verbose:
        print "shipper: variable extraction finished"

    # Finally, derive the lastchange entry; we'll need it for
    # freecode.com
    lastchange = None
    for filename in ("NEWS", "HISTORY", "ChangeLog"):
        if not lastchange and os.path.exists(filename):
            if options.verbose:
                print("shipper: I see a %s file" % filename)
            state = 0
            for line in open(filename, "r"):
                if state == 0:       # Skipping header
                    if line.startswith(" ") or line.startswith("\t"):
                        continue
                    elif not line.strip():
                        continue
                    else:
                        # Skip first line in the log entry.
                        lastchange = ""
                        state = 1
                elif state == 1:     # Past header
                    if not line.strip():
                        break
                    else:
                        lastchange += line
    if not lastchange and metadata.lastchange:
        lastchange = metadata.lastchange
    if 'freecode' in destinations and not lastchange:
        croak("Freecode notification requires a NEWS, HISTORY or ChangeLog file.")

    # Some destinations imply website locations
    if not website:
        if "sourceforge" in destinations:
            website = "http://%s.sourceforge.net/" % sourceforge_name
        if "savannah" in destinations:
            website = "http://www.nongnu.org/%s/" % savannah_name
        if "berlios" in destinations:
            website = "http://%s.berlios.de/" % berlios_name

    # Download directory has to be computed differently at
    # special destinations.
    if website:
        if "savannah" in website:
            download = "http://download.savannah.nongnu.org/releases/%s/"+(savannah_name or package)
        if "berlios"in website:
            download = "http://download.berlios.de/"+(berlios_name or package)
        elif "sourceforge" in website:
            download = "http://sourceforge.net/projects/%s/files/" % (
                sourceforge_name)
            if sourceforge_folder:
                download += sourceforge_folder + '/'
        else:
            download = website 

    #
    # Now compute the names of deliverables
    #
    def versioned(fn):
        "Does the specified filename contain a version number?"
        return re.search("[0-9]", fn)

    if options.verbose:
        print("shipper: starting deliverables computation")

    deliverable_types = (
        (re.compile("^README$"),
         "roadmap file",
         None,
         False),
        (re.compile("^READ.ME$"),
         "roadmap file",
         None,
         False),
        (re.compile("^ChangeLog$"),
         "change log",
         "ChangeLog",
         False),
        (re.compile("^NEWS$"),
         "project news",
         None,
         False),
        (re.compile("^HISTORY$"),
         "project history",
         None,
         False),
        (re.compile("^BUGS$"),
         "known bugs",
         None,
         False),
        (re.compile("^TODO$"),
         "to-do file",
         None,
         False),
        (re.compile("^COPYING$"),
         "project license",
         None,
         False),
        (re.compile(".*-" + str(version) + r".(tar.gz|tgz)$"),
         "gzipped source tarball",
         "Tar/GZ",
         True),
        (re.compile(package + ".*-" + str(version) + r".tar.bz2$"),
         "bzipped source tarball",
         "Tar/BZ",
         True),
        (re.compile(package + ".*-" + str(version) + r".md5$"),
         "source tarball MD5 checksum",
         "Checksum",
         True),
        (re.compile(package + ".*-" + str(version) + r".sha224$"),
         "source tarball SHA224 checksum",
         "Checksum",
         True),
        (re.compile(package + ".*-" + str(version) + r".sha256$"),
         "source tarball SHA256 checksum",
         "Checksum",
         True),
        (re.compile(package + ".*-" + str(version) + r".sha384$"),
         "source tarball SHA384 checksum",
         "Checksum",
         True),
        (re.compile(package + ".*-" + str(version) + r".sha512$"),
         "source tarball SHA512 checksum",
         "Checksum",
         True),
        (re.compile(package + ".*-" + str(version) + r".zip$"),
         "zip archive",
         "Zip",
         True),
        (re.compile(package + ".*-" + str(version) + r"-.*\.src.rpm$"),
         "source RPM",
         "SRPM-Package",
         True),
        (re.compile(package + ".*-" + str(version) + r"-.*\.rpm$"),
         "binary RPM",
         "RPM-Package",
         True),
        (re.compile(package + ".*-" + str(version) + r"-.*\.deb$"),
         "Debian package",
         "Debian-Package",
         True),
        )
    deliverables = []
    for filename in os.listdir("."):
        for (regexp, explanation, tag, bulky) in deliverable_types: 
            if regexp.search(filename):
                if not bulky:
                    with open(filename) as fp:
                        if re.search("^shipper: ignore this", fp.read()):
                            continue
                deliverables.append((filename, explanation, tag, bulky))
    if options.verbose:
        print("shipper: deliverables: " + " ".join([x[0] for x in deliverables]))

    #
    # Might be time to dump
    #
    if options.dump:
        # Single-line 
        for variable in ('package', 'version',
                         'destinations', 'whoami', 'gittip_id', 'date', 
                         'website', 'project_tags', 
                         'freecode_name', 'berlios_name',
                         'savannah_id', 'savannah_name',
                         'gitorious_url', 'github_url', 'ohloh_url',
                         'irc_channel',
                         'sourceforge_name', 'sourceforge_folder',
                         'summary', 'webdir', 'web_extras', 'logo',
                         'tag_template', 'tag_message', 'irc_message',
                         "html_target"):
            print("%s = %s" % (variable, repr(eval(variable))))
        # Free text, multiline
        for variable in ('description', 'changelog', 'lastchange',
                         'extralines', 'mail_template', 'html_template'):
            if not eval(variable):
                print("No %s" % variable)
            else:
                print("%s = <<EOF\n%sEOF" % (variable, eval(variable)))
        raise SystemExit(0)
    #
    # Build deliverables
    #

    # Sanity checks
    if not destinations:
        croak("the Destinations list is empty; nothing to do.")
    if not options.webonly and not [f_e_t_b[0] for f_e_t_b in deliverables if versioned(f_e_t_b[0])]:
        croak("no deliverables with versions!")

    if options.verbose:
        print("shipper: sanity checks passed")

    if not webdir:
        # Compute web-related deliverables, we need this even if not rebuilding
        # the templated page. Includes anything with an HTML, Javascript, or CSS
        # extension.
        for filename in glob.glob('*.html')+glob.glob('*.xhtml')+glob.glob('*.js')+glob.glob('*.css'):
            if filename == html_target:
                continue
            stem = filename[:-4]
            for ext in ("man", "1", "2", "3", "4", "5", "6", "7", "8", "9", "xml"):
                if os.path.exists(stem + ext):
                    explanation = "HTML rendering of " + stem + ext
                    break
            else:
                # If the HTML has a <title> element, use it.
                m = re.search("<title>([^<]*)</title>", open(filename).read())
                if m:
                    explanation = m.group(1)
                else:
                    explanation = "HTML page."
            deliverables.append((filename, explanation, None, False))
        if web_extras is not None:
            for fn in web_extras.split():
                firstline = open(fn).readline()
                if firstline.startswith("#"):
                    explanation = firstline[1:].strip()
                else:
                    explanation = "Custom web deliverable"
                deliverables.append((fn, explanation, None, False))

        # Template a resource page?
        if html_template and html_target:
            make_templated_page(deliverables, globals(), html_target)
            # Now that the web page has been generated, it can add
            # itself to the deliverables without having it show up in
            # the resource table.
            deliverables.append((html_target, "templated web page", None, False))

        # We'll want the logo if it exists, too
        if logo:
            deliverables.append((logo, "project logo", None, False))

    # Compute final deliverables.  This computation needs to coincide
    # with the way web deliverables are distinguished from download
    # deliverables in make_templated_page(), otherwise havoc will ensue.
    all_deliverables = [x[0] for x in deliverables]
    download_deliverables = [x[0] for x in [f_e_s_b for f_e_s_b in deliverables if f_e_s_b[3]]]
    web_deliverables = [x[0] for x in [f_e_s_b1 for f_e_s_b1 in deliverables if not f_e_s_b1[3]]]

    # Shipping methods for public destinations.
    def savannah():
        if not options.webonly:
            upload("dl.sv.nongnu.org:/releases/%s/" % savannah_name,
                   download_deliverables)
        # This code is weird and complicated because what Savannah wants
        # you to do is check out a per-project CVS repository for the
        # web pages, make changes to that repo, and commit it.
        # See http://savannah.gnu.org/maintenance/HomepageUpload
        # Sometime after this commit a cron job will run and check out
        # the visible version of the webpage(s). 
        #
        # We're using -kb to avoid keyword expansion on binary files.
        tmpdir = tempfile.mkdtemp()
        print("cd %s; cvs -z3 -kb -d:ext:%s@cvs.sv.gnu.org:/web/%s co %s" \
                  % (tmpdir, savannah_id, savannah_name, savannah_name))
        if not webdir:
            deliver = " ".join(web_deliverables)
        else:
            deliver = []
            for path, dirs, files in os.walk(webdir):
                for fn in files:
                    deliver.append(os.path.join(path, fn))
        for source in deliver:
            dirparts = source.split(os.sep)
            for i in range(1, len(dirparts)):
                source_subdir = os.sep.join(dirparts[:i])
                target_subdir = os.path.join(tmpdir,
                                             savannah_name,
                                             source_subdir)
                if not os.path.exists(target_subdir):
                    print("cd %s/%s; cvs add %s"
                                  % (tmpdir, savannah_name, source_subdir))
                elif not os.path.isdir(target_subdir):
                    # If this ever happens, you'll need to delete the
                    # offending file by hand.
                    sys.stderr.write(
                        "%s already exists as non-directory!" % \
                        target_subdir)
                    raise SystemExit, 1
            target = os.path.join(tmpdir, savannah_name, source)
            pre_existing = os.path.exists(target)
            shutil.copyfile(source, target)
            # This code handles additions, but you'll have to do
            # deletions by hand. Assuming you ever care.  
            if not pre_existing:
                print("cd %s/%s; cvs add %s"
                               % (tmpdir, savannah_name, source))
        print("cd %s/%s; cvs commit" % (tmpdir, savannah_name))
    def berlios():
        upload("ftp://ftp.berlios.de/incoming", download_deliverables)
        berlios_webdir = \
                       "shell.berlios.de:/home/groups/" \
                       + (berlios_name or package) \
                       + "/htdocs"
        upload(berlios_webdir, web_deliverables, subdir="")
    def sourceforge():
        if not options.webonly:
            # See https://sourceforge.net/apps/trac/sourceforge/wiki/Release%20files%20for%20download
            destdir =  "/home/frs/project/%s" % sourceforge_name
            if sourceforge_folder:
                destdir += "/" + sourceforge_folder
            print("rsync -avP -e ssh %s '%s,%s@frs.sourceforge.net:%s'" % (
                " ".join(download_deliverables),
                sourceforge_userid,
                sourceforge_name,
                destdir))
        if webdir:
            websources = webdir + '/'
        else:
            websources = " ".join(web_deliverables),
        # https://sourceforge.net/apps/trac/sourceforge/wiki/Rsync%20over%20SSH
        print("rsync -aiv %s %s,%s@web.sourceforge.net:/home/project-web/%s/htdocs/" % (
            websources,
            sourceforge_userid,
            sourceforge_name,
            sourceforge_name))
    hardwired = ("berlios", "savannah", "sourceforge")

    if options.verbose:
        print("Destinations: " + ", ".join(destinations))

    #
    # OK, commands for everything.  First, the uploads
    #
    for destination in destinations:
        if destination in hardwired:
            eval(destination + "()")
        elif destination.startswith("ftp:"):
            if not options.webonly:
                upload(destination, download_deliverables)
        elif destination.startswith("mailto:"):
            pass	# defer this until a later phase
        elif destination.startswith("irc:"):
            pass	# defer this until a later phase
        elif destination == 'freecode':
            pass	# defer this until a later phase
        elif destination not in hardwired:
            if options.webonly:
                upload(destination, web_deliverables)
            else:
                upload(destination, all_deliverables)

    if not options.webonly:
        # Tag the release
        if tag_template and tag_message:
            tagname = tag_template % globals()
            tag_message = tag_message % globals()

            # If we're in the trunk of an SVN repository, we want to tag
            # what just got shipped as an external release.
            if os.path.basename(os.getcwd())=='trunk' and os.path.exists(".svn"):
                print("# This is a Subversion trunk directory...")
                if os.path.exists("../tags"):
                    print("# I see an svn peer tags directory...")
                    if os.path.exists("../tags/" + tagname):
                        print("# This release has aleady been tagged.")
                    else:
                        print("# I will copy and tag this release as %s." % tagname)
                        print("cd .. && svn copy trunk tags/%s && svn -m '%s' commit" % (tagname, tag_message))
            for (idir, what, tagger, pusher) in (
                (".git", "git", "git tag -a %(tagname)s -m '%(tag_message)s'", "git push; git push --tags"),
                (".hg",  "hg",  "hg tag %(tagname)s -m '%(tag_message)s'", "hg push"),
                (".bzr", "bzr", "bzr tag %(tagname)s", "bzr push"),
                ):
                if os.path.exists(idir):
                    print(tagger % globals())
                    print(pusher % globals())

        # Freecode notification, after uploads and tagging
        if 'freecode' in destinations:
            if not website:
                print("# Can't announce to freecode without a primary website!")
            elif not lastchange:
                print("# Can't announce to freecode without a changes field!")
            else:
                print("freecode-submit <<'INAGADAVIDA'")
                print("Project: %s" % (freecode_name or package))
                print("Version: %s" % version)            
                print("Description: %s" % description.replace("\n", "\n    ").rstrip())
                if project_tags:
                    print("Project-Tag-List: %s" % project_tags)
                print("Website-URL: %s" % website)
                for (f, e, s, b) in deliverables:
                    if s:
                        if b:
                            url = download
                        else:
                            url = website
                        url = os.path.join(url, f)
                        print("%s-URL: %s" % (s, url))
                # freecode.com doesn't like bulleted entries.
                freecodelog = [s.lstrip() for s in lastchange.split("\n")]
                sys.stdout.write("\n" + "\n".join(freecodelog))
                print("INAGADADAVIDA\n")

        # Email notifications
        maildests = [x[7:] for x in destinations if x.startswith("mailto:")]
        if maildests:
            print("sendmail %s <<'INAGADADAVIDA'" % " ".join(maildests))
            print(mail_template % globals())
            print("INAGADADAVIDA\n")

        # Ship to IRC channels
        if irc_channel:
            irc_destinations = [chan for chan in destination \
                                if chan.startswith("irc:")]
            for url in  irc_destinations + irc_channel.split(","):
                msg = irc_message % globals()
                print("irk %s '%s'" % (url, msg))

    print("# That's all, folks!")
except KeyboardInterrupt:
    print("# Bye!")

# The following sets edit modes for GNU EMACS
# Local Variables:
# mode:python
# End:
