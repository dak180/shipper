#!/usr/bin/env python
#
# shipper -- a tool for shipping software

import sys, os, readline, re, commands, time, glob, optparse

#
# State variables
#
destinations = []	# List of remote directories to update
whoami = None		# Who am I? (Used for FTP logins)
date = None		# User has not yet set a date
package = None   	# Nor a package name
homepage = None		# Nor a home page
arch = None       	# The machine architecture
keywords = None  	# Keywords for LSMs
freshmeat_name = None	# Name of the project ob Freshmeat
changelog = None	# Project changelog
lastchange = None  	# Last entry in changelog
description = None	# Nor a description

indextemplate = """
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html>
<head>
<link rel='stylesheet' href='/~esr/sitestyle.css' type='text/css' />
<meta name='description' content='Resource page for %(package)s' />
<meta name='generator' content='shipper' />
<meta name='MSSmartTagsPreventParsing' content='TRUE' />
<title>Resource page for %(package)s %(version)s</title>
</head>
<body>

<h1>Resource page for %(package)s %(version)s</td></h1>

<p>%(description)s</p>

<br />
%(resourcetable)s
<br />

<p>Last modified %(date)s.</p>

</div>
</body>
</html>
"""
mailtemplate = """Subject: Announcing release %(version)s of %(package)s

Release %(version)s of %(package)s is now available at:

	%(homepage)s

Here are the most recent changes:

%(lastchange)s
--
                             shipper, acting for %(whoami)s
"""

# It's unpleasant that we have to include these here, but
# the freshmeat release focus has to be validated even if the
# user is offline and the XML-RPC service not accessible.
freshmeat_focus_types = (
"N/A",
"Initial freshmeat announcement",
"Documentation",
"Code cleanup",
"Minor feature enhancements",
"Major feature enhancements",
"Minor bugfixes",
"Major bugfixes",
"Minor security fixes",
"Major security fixes",
)

def croak(msg):
    sys.stderr.write("shipper: " + msg + "\n")
    sys.exit(1)

#
# Shipping methods
#

def do_or_die(cmd):
    "Wither execute a command or fail noisily"
    if options.verbose:
        print "***", cmd
    if os.system(cmd):
        croak("command '%s' failed!" % cmd)

def upload(destination, files):
    # Upload a file via ftp or sftp, handles 
    print "# Uploading to %s" % destination
    if destination.startswith("ftp://"):
        destination = destination[6:].split("/")
        host = destination.pop(0)
        directory = "/".join(destination)
        commands = ["open -u anonymous," + whoami + " " + host]
        if directory:
            commands.append("cd " + directory)
        found = ""
        for file in files:
            if not os.path.exists(file):
                if options.verbose:
                    print "Upload of %s to %s skipped." % (file, destination)
            else:
                found += " " + file
        commands.append("mput" + found)
        commands.append("close")
    else:
        commands = ["sftp -C " + destination]
        for file in files:
            if not os.path.exists(file):
                if options.verbose:
                    print "Upload of %s to %s skipped." % (file, destination)
            else:
                commands.append("put -P " + file + " " + file + ".new")
                commands.append("mv " + file + ".new " + file)
        commands.append("bye")
    # Here goes the actual upload
    if options.noupload:
        print "\n".join(commands)
    else:
        pfp = os.popen(commands.pop(0))
        pfp.writelines(commands)
        pfp.close()

def freshmeat_ship(manifest):
    "Ship a specified update to freshmeat."
    if options.verbose:
        print "Announcing to freshmeat..."
    command = "freshmeat-submit <" + manifest[0]
    if options.noupload:
        print command
    else:
        do_or_die(command)

#
# Metadata extraction
#

def grep(pattern, file):
    "Mine for a specified pattern in a file."
    fp = open(file)
    while True:
        line = fp.readline()
        if not line:
            return None
        m = re.search(pattern, line, re.I)
        if m:
            return m.group(1)
    fp.close()

def get_metadata(fieldname):
    "Fetch package metadata."
    # Someday we'll support getting metadata from Debian control files
    if not os.path.exists(specfile):
        return None
    if fieldname in ("description", "changelog"):
        # Grab everything from leader line to just before the next blank line
        global desc
        fp = open(specfile)
        desc = ""
        gather = False
        while True:
            line = fp.readline()
            if not line:
                break
            if line.startswith("%" + fieldname):
                gather = True
                continue
            elif not line.strip():
                gather = False
            if gather:
                desc += line
        return desc
    else:
        return grep("^#?"+fieldname+": (.*)",specfile)

#
# Main sequence
#

try:
    #
    # Process options
    #

    parser = optparse.OptionParser(usage="%prog: [-h] [-n] [-f] [-v]")
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="print progress messages to stdout")
    parser.add_option("-n", "--noupload",
                      action="store_true", dest="noupload", default=False,
                      help="don't do uploads, just build deliverables")
    parser.add_option("-f", "--force",
                      action="store_true", dest="force", default=False,
                      help="force rebuilding of all local deliverables")
    (options, args) = parser.parse_args()

    #
    # Extract metadata and compute control information
    #

    # Read in variable overrides
    home_profile = os.path.join(os.getenv('HOME'), ".shipper")
    if os.path.exists(home_profile):
        execfile(home_profile)
    here_profile = ".shipper"
    if os.path.exists(here_profile):
        execfile(here_profile)

    # Set various sensible defaults
    if not whoami:
        whoami = os.getenv('USERNAME') + "@" + os.getenv('HOSTNAME')

    # Where to get the metadata
    specfiles = glob.glob("*.spec")
    if len(specfiles) == 1:
        specfile = specfiles[0]
    else:
        croak("there must be exactly one specfile in the directory!")

    # Get the package name
    if not package:
        package = get_metadata("name")
    if not package:
        croak("can't get package name!")

    # Extract the package vers from the specfile or Makefile
    specvers = get_metadata("version")
    makevers = None
    if os.path.exists("Makefile"):
        makevers = grep("^VERS[A-Z]* *= *(.*)", "Makefile")
        # Maybe it's a shell command intended to extract version from specfile
        if makevers[0] == '$':
            makevers = commands.getoutput(makevers[7:-1])
    if specvers != makevers:
        croak("specfile version %s != Makefile version %s"%(specvers,makevers))
    elif specvers == None:
        croak("can't get package version")
    elif specvers[0] not in "0123456789":
        croak("package version %s appears garbled" % specvers)
    else:
        version = specvers

    # Specfiles may set their own destinations
    local_destinations = get_metadata("destinations")
    if local_destinations:
        local_destinations = map(lambda x: x.strip(), local_destinations.split(","))
        destinations += local_destinations
    if not destinations:
        croak("no destinations specified!")

    print"# Uploading version %s of %s" % (version, package)

    # Extract remaining variables for templating
    if not homepage:
        homepage = get_metadata("URL")
    if not date:
        date = time.asctime()
    if not description:
        description = get_metadata("description").strip()
    arch = get_metadata("BuildArch") or commands.getoutput("rpm --showrc | sed -n '/^build arch/s/.* //p'")

    #
    # Now compute the names of deliverables
    #

    # These are all potential deliverable files that include the version number
    tarball   = package + "-" + version + ".tar.gz"
    srcrpm    = package + "-" + version + "-1.src.rpm"
    binrpm    = package + "-" + version + "-1." + arch + ".rpm"
    zip       = package + "-" + version + ".zip"
    lsm       = package + "-" + version + ".lsm"

    # Map web deliverables to explanations for the resource table
    # Stuff niot included here: ANNOUNCE.EMAIL, ANNOUNCE.FRESHMEAT, lsm.
    stock_deliverables = [
        ("README", "roadmap file"),
        (tarball,  "source tarball"),
        (zip,      "ZIP archive"),
        (binrpm,   "installable RPM"),		# Generated
        (srcrpm,   "source RPM"),			# Generated
        ("CHANGES","Changelog file"),		# Generated
        ("NEWS",   "Project news"),
        ("HISTORY","Project history"),
        ("BUGS",   "Known bugs"),
        ("TODO",   "To-do file"),
        ]

    #
    # Build deliverables
    #

    suppress = " >/dev/null 2>&1"
    if options.verbose:
        suppress = ""

    # Sanity checks
    if not os.path.exists(tarball):
        croak("no tarball %s, check your make dist command!" % tarball)
    if not os.path.exists(specfile):
        croak("no specfile %s, can't build RPMs!" % specfile)
    if not get_metadata("BuildRoot"):
        croak("specfile %s doesn't have a BuildRoot!" % specfile)

    # RPMs first.
    if options.force or (not os.path.exists(binrpm) or not os.path.exists(srcrpm)):
        print "# Building RPMs..."
        if get_metadata("target") == "noarch":
            do_or_die("buildrpms %s noarch %s" % (tarball, suppress))
        else:
            do_or_die("buildrpms %s %s" % (tarball, suppress))

    # Now that we have RPMs, extract the changelog information
    changelog = commands.getoutput("rpm --changelog -qp " + binrpm)
    lastchange = ""
    for line in changelog.split("\n"):
        if not lastchange and (not line.strip() or line[0] == '*'):
            continue
        elif line.strip():
            lastchange += line + "\n"
        else:
            break

    # Next, the LSM if needed
    if options.force or (not os.path.exists(lsm) and 'ibiblio' in channels):
        print "# Building LSM..."
        keywords = get_metadata("keywords")
        if keywords:
            do_or_die("rpm2lsm -k '" + keywords +  "' " + binrpm + " >" + lsm)
        else:
            print "# Warning: LSM being built with no keywords." 
            do_or_die("rpm2lsm " + binrpm + ">" + lsm)

    # Next the index page if it doesn't exist
    if options.force or not os.path.exists("index.html"):
        print "# Building index page..."
        web_deliverables = []
        # Anything in the list of standard deliverables is eligible.
        for (file, explanation) in stock_deliverables:
            if os.path.exists(file):
                web_deliverables.append((file, explanation))
        # So is anything with an HTML extendion
        for file in glob.glob('*.html'):
            if file == 'index.html':
                continue
            stem = file[:-4]
            for ext in ("man", "1", "2", "3", "4", "5", "6", "7", "8", "9", "xml"):
                if os.path.exists(stem + ext):
                    explanation = "HTML rendering of " + stem + ext
                    break
            else:
                explanation = "HTML page."
            web_deliverables.append((file, explanation))
        # Now that we've computed all deliverables, build the resource table
        resourcetable = '<table border="1" align="center" summary="Downloadable resources">\n'
        for (file, explanation) in web_deliverables:
            resourcetable += "<tr><td><a href='%s'>%s</a></td><td>%s</td></tr>\n" % (file,file,explanation)
        resourcetable += "</table>"
        # OK, now build the index page itself
        ofp = open("index.html", "w")
        ofp.write(indextemplate % globals())
        ofp.close()
        # Compute final deliverables
        web_deliverables = map(lambda x: x[0], web_deliverables)+["index.html"]

    # Next the CHANGES file
    if options.force or not os.path.exists("CHANGES"):
        print "# Building CHANGES..."
        ofp = open("CHANGES", "w")
        ofp.write("                     Changelog for " + package + "\n\n")
        ofp.write(changelog)
        ofp.close()

    # The freshmeat announcement
    if options.force or not os.path.exists("ANNOUNCE.FRESHMEAT"):
        print "# Building ANNOUNCE.FRESHMEAT..."
        if not get_metadata("URL"):
            print "# Can't announce to freshmeat without a primary website!"
        else:
            focus = raw_input("# freshmeat.net release focus: ")
            if focus in "0123456789":
                print "# OK:", freshmeat_focus_types[int(focus)]
            elif focus.lower() not in map(lambda x: x.lower(), freshmeat_focus_types):
                croak("not a valid freshmeat.net release focus!")
            ofp = open("ANNOUNCE.FRESHMEAT", "w")
            ofp.write("Project: %s\n"%(get_metadata("freshmeat-name") or package))
            ofp.write("Version: %s\n"% version)
            ofp.write("Release-Focus: %s\n" % focus)
            ofp.write("Home-Page-URL: %s\n" % homepage)
            if os.path.exists(tarball):
                ofp.write("Gzipped-Tar-URL: %s\n" % os.path.join(homepage,tarball))
            if os.path.exists(zip):
                ofp.write("Zipped-Tar-URL: %s\n" % os.path.join(homepage, zip))
            if os.path.exists("CHANGES"):
                ofp.write("Changelog-URL: %s\n" % os.path.join(homepage, "CHANGES"))
            if os.path.exists(binrpm):
                ofp.write("RPM-URL: %s\n" % os.path.join(homepage, binrpm))
            # freshmeat.net doesn't like bulleted entries.
            freshmeatlog = lastchange[2:].replace("\n  ", "\n")
            ofp.write("\n" + freshmeatlog)
            ofp.close()

    # Finally, email notification
    if options.force or not os.path.exists("ANNOUNCE.EMAIL"):
        print "# Building ANNOUNCE.EMAIL..."
        ofp = open("ANNOUNCE.EMAIL", "w")
        ofp.write(mailtemplate % globals())
        ofp.close()

    #
    # Now actually ship
    #

    # Shipping methods, locations, and deliverables for public channels.
    hardwired = {
        'freshmeat.net' : (lambda: freshmeat_ship(("ANNOUNCE.FRESHMEAT",))),
        'ibiblio'       : (lambda: upload("ftp://ibiblio.org/incoming/linux",
                                      (tarball, binrpm, srcrpm, lsm))),
        'redhat'        : (lambda: upload("ftp://incoming.redhat.com/libc6", 
                                      (tarball, binrpm, srcrpm))),
    }

    # First ship to private channels.
    # Order is important here, we need to hit the user's primary website first
    # so everything will be in place when announcements are generated.
    for destination in destinations:
        if destination.startswith("ftp:"):
            upload(destination, (tarball, binrpm, srcrpm,))
        elif destination.startswith("mailto:"):
            do_or_die("sendmail -i -oem %s <ANNOUNCE.ENAIL" % destination[7:])
        else:
            upload(destination, web_deliverables)

    # Now ship to to public channels
    for (channel, shipper) in hardwired.items() :
        print "# Shipping to public channel", channel
        apply(shipper)

    print "# Done"
except KeyboardInterrupt:
    print "# Bye!"

# The following sets edit modes for GNU EMACS
# Local Variables:
# mode:python
# End:
