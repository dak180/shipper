#!/bin/sh
#
# Upload a release to all the standard places.

# This needs to specify the following:
# siteurl	= site URL of your Web distribution directory 
# webaccount	= how ssh gets to your account on the Web host
# webdir	= the distribution directory on that host
# arch  	= architecture, for binary-RPM purposes
# indextemplate = template for the generated index page.
#
. ${HOME}/.shipit

notify=echo
while getopts dhk:wpr:t:fF: c;
do
  case $c in
   'd') noupload=echo dumpcmds=yes notify=: ;;	# List upload commands
   'h') hide=yes ;;
   'k') keywords="$OPTARG" ;;
   'w') noupload=: pagedump=yes notify=: ;;	# List generated web page
   'p') primary=: ;;				# Changes only primary site
   'r') releasefocus="$OPTARG";;
   'a') target="$OPTARG" ;;
   'f') freshmeatonly=yes noupload=echo ;;
   'F') freshmeatopts="$OPTARG" ;;
   '?') echo "shipit: invalid switch specified - aborting."; exit 1;;
  esac
done
shift `expr $OPTIND - 1`

# If the package name wasn't passed as an argument,
# assume it's the basename of the enclosing directory.
package=$1
if [ -z "$package" ]
then
    package=`basename $PWD`
fi

# Extract the package version from the Makefile
if [ -f Makefile ]
then
    version=`sed -n '/^VERS[A-Z]* *= *\([^	 ]*\)/s//\1/p' <Makefile`
    # Maybe it's a shell command intended to extract version from specfile
    if expr "${version}" : '$.*' >/dev/null
    then
	version=`echo "$version" | sed -n '/\$(shell \(.*\))/s//\1/p' | sh`
    fi
else
    echo "shipit: can't get package ${package} version" 1>&2
    exit 1
fi

echo "Uploading version ${version} of ${package}" 1>&2

projecturl=${siteurl}${package}/

# Compute names of shippable files
if [ -n "$version" ]
then
    tarball=${package}-${version}.tar.gz
    binrpm=${package}-${version}-1.${arch}.rpm
    srcrpm=${package}-${version}-1.src.rpm
    noarchrpm=${package}-${version}-1.noarch.rpm
    zip=${package}-${version}.zip
else
    tarball=$package
    binrpm=''
    srcrpm=''
    noarchrpm=''
    zip=''
fi
lsm=${package}.lsm
html=${package}.html

# We're going to need a couple of tempfiles
resources="/usr/tmp/resources.$$"
commands="/usr/tmp/commands.$$"
trap "rm -f $command" 0 2 15
resourcetable=''

fulldate=`date`
date=`date '+%Y-%m-%d'`

function upload() {
    # Upload a file with explanation
    file=$1		# File to upload
    explanation=$2	# Explanation to go with it 
    if [ -f "$file" ]
    then
	$notify "$explanation:"
	$noupload scp ${file} ${webaccount}:${webdir}/${package}/${file}.new
	$noupload ssh ${webaccount} "cd ${webdir}/${package}; rm -f ${file}; mv ${file}.new ${file}"
        if [ -n "$explanation" ]
	then
	    resourcetable="$resourcetable <tr><td>$explanation</td><td><a href='$file'>$file</a></td></tr>
"
	fi
    fi
}

function require() {
    # Crap out if a specified resource doesn't exist
    if [ ! -f $1 ]
    then
	    echo "$1 is missing"
	    exit 1
    fi
}

function ftp() {
    # FTP up to HOST/DIRECTORY all listed FILES
    host=$1
    shift
    dir=$1
    shift
    cat >$commands <<EOF
open -u anonymous,${USER}@${HOSTNAME} $host
cd $dir
EOF
    for file in $*
    do
        echo "put $file" >>$commands
    done
    echo "close" >>$commands
    if [ -n "$dumpcmds" ]
    then
	cat $commands
    elif [ -z "$noupload" ]
    then
	$notify "FTP $host/$dir:"
	lftp <$commands
    fi
}

function genpage() {
    # Generate web page from RPM metadata to stdout -- call *after* all uploads
    rpm=$1

    name=$package
    release=1
    if [ $rpm ]
    then
	# Mine out metadata to put on the index file
	# Mine out all the single-token fields we'll need
	set -- `rpm --queryformat="%{name} %{version} %{release}" -qp $rpm`
	name=$1
	version=$2
	release=$3

	if [ -f blurb.html ]
	then
	    # Maybe there's a blurb here?
	    description=`cat blurb.html`
	else
	    # Extract and reformat the desciption from the RPM
	    description=`rpm --queryformat="%{description}" -qp $rpm`
	fi
    elif [ -f "${package}.lsm" ]
    then
	 description=`(
	    keep=0
	    while read line
	    do
	      if expr match "$line" "Description:" >/dev/null
	      then
		  keep=1
		  echo $line | sed 's/Description: *//'
		  continue
	      elif expr match "$line" "[A-Za-z]*:" >/dev/null
	      then
		  keep=0
	      fi
	      if [ $keep = 1 ]
	      then
		  echo $line
	      fi
	    done
	) <${package}.lsm`
    fi


    hd='<table border="1" align="center" summary="Downloadable resources">
'
    resourcetable="$hd$resourcetable</table>"
    eval "echo \"$indextemplate\""
}

#
# Main sequence
#

# Figure out what to mine metadata out of
if [ -f $binrpm ]
then
    # It's a binary distribution
    require $srcrpm
    rpmlist="$binrpm $srcrpm"
    queryable=$binrpm
elif [ -f $noarchrpm ]
then
    rpmlist=$noarchrpm
    queryable=$noarchrpm
else
    rpmlist=''
    queryable=''
    echo "RPM files missing in ${package}." >&2
fi

# Maybe there is HTML documentation we can upload?
# If there an XML file, maybe the HTML needs to be rebuilt.
if [ -f ${package}.xml -a \( ! -f ${package}.html -o \( ${package}.xml -nt ${package}.html \) \) ]
then
    xmlto xhtml-nochunks ${package}.xml
fi

# Maybe we can make a CHANGES file from the changelog entry in the RPM spec.
if [ -f "${package}.spec" -a ! -f NEWS -a ! -f HISTORY ]
then
    echo "Generating CHANGES file from RPM spec..."
    echo "               CHANGES file for project $package" >CHANGES
    echo "" >>CHANGES
    sed <"${package}.spec" >>CHANGES -e '1,/%changelog/d'
fi

# Make RPMS, if possible.  Relies on make dist creating a tarball
# with an embedded spec file.
make dist
if [ "$target" ]
then
    buildrpms --target ${target} ${tarball} || exit 1
else
    buildrpms ${tarball} || exit 1
fi

# Generate an LSM file if we have an RPM file to do it from
if [ -f ${queryable} ]
then
    rpm2lsm -k "$keywords" $queryable >$lsm
fi

# First copy to primary website
upload "READ.ME"  "READ.ME file"
upload "README"   "README file"
upload $html      "Manual page"
upload $tarball   "Source tarball"
upload $binrpm    "Binary RPM"
upload $srcrpm    "Source RPM"
upload $noarchrpm "Noarch RPM"
upload $zip       "Zip file archive"
upload "NEWS"     "News file"
upload "CHANGES"  "Changelog file"
upload "BUGS"     "Known bugs"
upload "TODO"     "To-do list"

# Ship to Red Hat and ibiblio unless we've said not to
if [ -z "$primary" ]
then
    ftp ibiblio.org incoming/linux $lsm $tarball $rpmlist
    ftp incoming.redhat.com libc6 $rpmlist
fi

# Now deal with the web page
if [ -n "$pagedump" ]
then
    genpage $queryable
else
    # No page?  Then generate one.
    if [ ! -f index.html ]
    then
	genpage $queryable >index.html;
    fi
    # Refresh this package's index page on the primary site 
    upload index.html "Web page" $dest
fi

# Send an update to Freshmeat
echo "Updating Freshmeat..."
locs=''
if [ -f $tarball ] 
then
    locs="$locs --gzipped-tar-url=${projecturl}${tarball}"
fi
if [ -f $binrpm ] 
then 
    locs="$locs --rpm-url=${projecturl}${binrpm}" 
elif [ -f $srcrpm ] 
then
    locs="$locs --rpm-url=${projecturl}${srcrpm}"
elif [ -f $noarchrpm ]
then 
    locs="$locs --rpm-url=${projecturl}${noarchrpm}"
fi
if [ -f CHANGES ]
then
    locs="$locs --changelog-url=${projecturl}CHANGES"
fi

if [ ! "$releasefocus" -a ! "$pagedump" ]
then
    echo -n "Release Focus: "
    read releasefocus
fi

if [ $noupload ]
then
    dumpopt=-N
else
    if [ -f $queryable ]
    then
	if [ "$hide" ]
	then
	    freshmeatopts="$freshmeatopts --hide=Y"
	fi
    fi
    rm -f CHANGES $lsm
fi
$noupload freshmeat-submit -n -r "${releasefocus}" ${freshmeatopts} ${dumpopt} ${locs} ${queryable}


echo "Upload finished"
# End
